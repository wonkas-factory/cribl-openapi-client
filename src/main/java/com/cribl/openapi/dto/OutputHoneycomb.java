/*
 * Cribl LogStream
 * REST API Reference of available endpoints and their supported operations for accessing, updating, creating, or deleting resources. Product documentation available at [docs.cribl.io](http://docs.cribl.io).
 *
 * OpenAPI spec version: 3.1.2-abb571bc
 * Contact: support@cribl.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.cribl.openapi.dto;

import java.util.Objects;
import java.util.Arrays;
import com.cribl.openapi.dto.Authentication;
import com.cribl.openapi.dto.KafkaSchemaRegistryAuthentication;
import com.cribl.openapi.dto.NotificationTargetRouterRules;
import com.cribl.openapi.dto.NotificationTargetWebhookExtraHttpHeaders;
import com.cribl.openapi.dto.OutputDefaultAuth;
import com.cribl.openapi.dto.OutputDefaultHosts;
import com.cribl.openapi.dto.OutputDefaultLabels;
import com.cribl.openapi.dto.OutputDefaultMetadata;
import com.cribl.openapi.dto.OutputDefaultPrometheusAuth;
import com.cribl.openapi.dto.TLSSettingsClientSide;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
/**
 * OutputHoneycomb
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2021-10-08T00:23:34.796-04:00[America/New_York]")
public class OutputHoneycomb implements OneOfOutput, AnyOfOutputHoneycomb {
  @SerializedName("id")
  private String id = null;

  /**
   * Gets or Sets type
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    LOKI("loki"),
    ROUTER("router"),
    TCPJSON("tcpjson"),
    SPLUNK("splunk"),
    SPLUNK_LB("splunk_lb"),
    SPLUNK_HEC("splunk_hec"),
    SYSLOG("syslog"),
    FILESYSTEM("filesystem"),
    S3("s3"),
    AZURE_BLOB("azure_blob"),
    AZURE_LOGS("azure_logs"),
    KAFKA("kafka"),
    KINESIS("kinesis"),
    ELASTIC("elastic"),
    HONEYCOMB("honeycomb"),
    NEWRELIC("newrelic"),
    NEWRELIC_EVENTS("newrelic_events"),
    SNMP("snmp"),
    INFLUXDB("influxdb"),
    MINIO("minio"),
    DEVNULL("devnull"),
    CLOUDWATCH("cloudwatch"),
    AZURE_EVENTHUB("azure_eventhub"),
    STATSD("statsd"),
    STATSD_EXT("statsd_ext"),
    GRAPHITE("graphite"),
    WAVEFRONT("wavefront"),
    SIGNALFX("signalfx"),
    SQS("sqs"),
    GOOGLE_CLOUD_STORAGE("google_cloud_storage"),
    SUMO_LOGIC("sumo_logic"),
    DATADOG("datadog"),
    WEBHOOK("webhook"),
    PROMETHEUS("prometheus"),
    GOOGLE_PUBSUB("google_pubsub"),
    GOOGLE_CHRONICLE("google_chronicle"),
    GRAFANA_CLOUD("grafana_cloud"),
    LOKI_37("loki");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TypeEnum fromValue(String text) {
      for (TypeEnum b : TypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return TypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("type")
  private TypeEnum type = null;

  @SerializedName("pipeline")
  private String pipeline = null;

  @SerializedName("systemFields")
  private List<String> systemFields = null;

  @SerializedName("defaultId")
  private String defaultId = null;

  @SerializedName("host")
  private String host = null;

  @SerializedName("port")
  private BigDecimal port = new BigDecimal(8125);

  /**
   * Codec to use to compress the data before sending to Kafka.
   */
  @JsonAdapter(CompressionEnum.Adapter.class)
  public enum CompressionEnum {
    NONE("none"),
    GZIP("gzip"),
    SNAPPY("snappy");

    private String value;

    CompressionEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static CompressionEnum fromValue(String text) {
      for (CompressionEnum b : CompressionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<CompressionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CompressionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CompressionEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return CompressionEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("compression")
  private CompressionEnum compression = CompressionEnum.NONE;

  @SerializedName("throttleRatePerSec")
  private String throttleRatePerSec = "0";

  @SerializedName("tls")
  private TLSSettingsClientSide tls = null;

  @SerializedName("connectionTimeout")
  private BigDecimal connectionTimeout = new BigDecimal(10000);

  @SerializedName("writeTimeout")
  private BigDecimal writeTimeout = new BigDecimal(60000);

  /**
   * Whether to block, drop, or queue events when all receivers in this group are exerting backpressure.
   */
  @JsonAdapter(OnBackpressureEnum.Adapter.class)
  public enum OnBackpressureEnum {
    BLOCK("block"),
    DROP("drop"),
    QUEUE("queue");

    private String value;

    OnBackpressureEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static OnBackpressureEnum fromValue(String text) {
      for (OnBackpressureEnum b : OnBackpressureEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<OnBackpressureEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OnBackpressureEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OnBackpressureEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return OnBackpressureEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("onBackpressure")
  private OnBackpressureEnum onBackpressure = OnBackpressureEnum.BLOCK;

  /**
   * The authentication method to use for the HTTP requests
   */
  @JsonAdapter(AuthTypeEnum.Adapter.class)
  public enum AuthTypeEnum {
    NONE("none"),
    TOKEN("token"),
    TEXTSECRET("textSecret"),
    BASIC("basic"),
    CREDENTIALSSECRET("credentialsSecret");

    private String value;

    AuthTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static AuthTypeEnum fromValue(String text) {
      for (AuthTypeEnum b : AuthTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<AuthTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AuthTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AuthTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return AuthTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("authType")
  private AuthTypeEnum authType = AuthTypeEnum.NONE;

  /**
   * Protocol to use when communicating with the destination.
   */
  @JsonAdapter(ProtocolEnum.Adapter.class)
  public enum ProtocolEnum {
    UDP("udp"),
    TCP("tcp");

    private String value;

    ProtocolEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ProtocolEnum fromValue(String text) {
      for (ProtocolEnum b : ProtocolEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ProtocolEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProtocolEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProtocolEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return ProtocolEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("protocol")
  private ProtocolEnum protocol = ProtocolEnum.UDP;

  /**
   * Default value for message facility, will be overwritten by value of __facility if set. Defaults to user.
   */
  @JsonAdapter(FacilityEnum.Adapter.class)
  public enum FacilityEnum {
    NUMBER_0(new BigDecimal(0)),
    NUMBER_1(new BigDecimal(1)),
    NUMBER_2(new BigDecimal(2)),
    NUMBER_3(new BigDecimal(3)),
    NUMBER_4(new BigDecimal(4)),
    NUMBER_5(new BigDecimal(5)),
    NUMBER_6(new BigDecimal(6)),
    NUMBER_7(new BigDecimal(7)),
    NUMBER_8(new BigDecimal(8)),
    NUMBER_9(new BigDecimal(9)),
    NUMBER_10(new BigDecimal(10)),
    NUMBER_11(new BigDecimal(11)),
    NUMBER_12(new BigDecimal(12)),
    NUMBER_13(new BigDecimal(13)),
    NUMBER_14(new BigDecimal(14)),
    NUMBER_15(new BigDecimal(15)),
    NUMBER_16(new BigDecimal(16)),
    NUMBER_17(new BigDecimal(17)),
    NUMBER_18(new BigDecimal(18)),
    NUMBER_19(new BigDecimal(19)),
    NUMBER_20(new BigDecimal(20)),
    NUMBER_21(new BigDecimal(21));

    private BigDecimal value;

    FacilityEnum(BigDecimal value) {
      this.value = value;
    }
    public BigDecimal getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static FacilityEnum fromValue(String text) {
      for (FacilityEnum b : FacilityEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<FacilityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FacilityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FacilityEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return FacilityEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("facility")
  private FacilityEnum facility = new BigDecimal(1);

  /**
   * Default value for message severity. When you send logs as JSON objects, the event&#x27;s &#x27;__severity&#x27; field (if set) will override this value.
   */
  @JsonAdapter(SeverityEnum.Adapter.class)
  public enum SeverityEnum {
    EMERGENCY("emergency"),
    ALERT("alert"),
    CRITICAL("critical"),
    ERROR("error"),
    WARNING("warning"),
    NOTICE("notice"),
    INFO("info"),
    DEBUG("debug");

    private String value;

    SeverityEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static SeverityEnum fromValue(String text) {
      for (SeverityEnum b : SeverityEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<SeverityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SeverityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SeverityEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return SeverityEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("severity")
  private SeverityEnum severity = SeverityEnum.INFO;

  @SerializedName("appName")
  private String appName = "Cribl";

  /**
   * Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf.
   */
  @JsonAdapter(MessageFormatEnum.Adapter.class)
  public enum MessageFormatEnum {
    PROTOBUF("protobuf"),
    JSON("json");

    private String value;

    MessageFormatEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static MessageFormatEnum fromValue(String text) {
      for (MessageFormatEnum b : MessageFormatEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<MessageFormatEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MessageFormatEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MessageFormatEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return MessageFormatEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("messageFormat")
  private MessageFormatEnum messageFormat = MessageFormatEnum.PROTOBUF;

  /**
   * Timestamp format to use when serializing event&#x27;s time field
   */
  @JsonAdapter(TimestampFormatEnum.Adapter.class)
  public enum TimestampFormatEnum {
    SYSLOG("syslog"),
    ISO8601("iso8601");

    private String value;

    TimestampFormatEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TimestampFormatEnum fromValue(String text) {
      for (TimestampFormatEnum b : TimestampFormatEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TimestampFormatEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TimestampFormatEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TimestampFormatEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return TimestampFormatEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("timestampFormat")
  private TimestampFormatEnum timestampFormat = TimestampFormatEnum.SYSLOG;

  /**
   * Specifies how to serialize nested fields into index-time fields.
   */
  @JsonAdapter(NestedFieldsEnum.Adapter.class)
  public enum NestedFieldsEnum {
    JSON("json"),
    NONE("none");

    private String value;

    NestedFieldsEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static NestedFieldsEnum fromValue(String text) {
      for (NestedFieldsEnum b : NestedFieldsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<NestedFieldsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final NestedFieldsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public NestedFieldsEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return NestedFieldsEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("nestedFields")
  private NestedFieldsEnum nestedFields = NestedFieldsEnum.NONE;

  @SerializedName("enableMultiMetrics")
  private Boolean enableMultiMetrics = false;

  @SerializedName("enableACK")
  private Boolean enableACK = true;

  @SerializedName("dnsResolvePeriodSec")
  private BigDecimal dnsResolvePeriodSec = new BigDecimal(600);

  @SerializedName("loadBalanceStatsPeriodSec")
  private BigDecimal loadBalanceStatsPeriodSec = new BigDecimal(300);

  @SerializedName("maxConcurrentSenders")
  private BigDecimal maxConcurrentSenders = new BigDecimal(0);

  @SerializedName("indexerDiscovery")
  private Boolean indexerDiscovery = false;

  @SerializedName("url")
  private String url = "http://localhost:8088/services/collector/event";

  @SerializedName("nextQueue")
  private String nextQueue = "indexQueue";

  @SerializedName("tcpRouting")
  private String tcpRouting = "nowhere";

  @SerializedName("concurrency")
  private BigDecimal concurrency = new BigDecimal(1);

  @SerializedName("maxPayloadSizeKB")
  private BigDecimal maxPayloadSizeKB = new BigDecimal(4096);

  @SerializedName("maxPayloadEvents")
  private BigDecimal maxPayloadEvents = new BigDecimal(0);

  @SerializedName("compress")
  private Boolean compress = false;

  @SerializedName("rejectUnauthorized")
  private Boolean rejectUnauthorized = false;

  @SerializedName("timeoutSec")
  private BigDecimal timeoutSec = new BigDecimal(30);

  @SerializedName("flushPeriodSec")
  private BigDecimal flushPeriodSec = new BigDecimal(15);

  @SerializedName("extraHttpHeaders")
  private List<NotificationTargetWebhookExtraHttpHeaders> extraHttpHeaders = null;

  @SerializedName("useRoundRobinDns")
  private Boolean useRoundRobinDns = false;

  @SerializedName("domain")
  private String domain = "longboard";

  @SerializedName("realm")
  private String realm = "us0";

  @SerializedName("destPath")
  private String destPath = null;

  @SerializedName("stagePath")
  private String stagePath = "$CRIBL_HOME/state/outputs/staging";

  @SerializedName("addIdToStagePath")
  private Boolean addIdToStagePath = true;

  @SerializedName("removeEmptyDirs")
  private Boolean removeEmptyDirs = false;

  @SerializedName("partitionExpr")
  private String partitionExpr = "`${host}/${sourcetype}`";

  /**
   * Specifies how to format events before sending out. Defaults to NDJSON.
   */
  @JsonAdapter(FormatEnum.Adapter.class)
  public enum FormatEnum {
    NDJSON("ndjson"),
    JSON_ARRAY("json_array"),
    CUSTOM("custom");

    private String value;

    FormatEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static FormatEnum fromValue(String text) {
      for (FormatEnum b : FormatEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<FormatEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FormatEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FormatEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return FormatEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("format")
  private FormatEnum format = FormatEnum.NDJSON;

  @SerializedName("baseFileName")
  private String baseFileName = "`CriblOut`";

  @SerializedName("maxFileSizeMB")
  private BigDecimal maxFileSizeMB = new BigDecimal(32);

  @SerializedName("maxFileOpenTimeSec")
  private BigDecimal maxFileOpenTimeSec = new BigDecimal(300);

  @SerializedName("maxFileIdleTimeSec")
  private BigDecimal maxFileIdleTimeSec = new BigDecimal(30);

  @SerializedName("maxOpenFiles")
  private BigDecimal maxOpenFiles = new BigDecimal(100);

  @SerializedName("bucket")
  private String bucket = null;

  /**
   * Region to publish messages to. Select &#x27;default&#x27; to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
   */
  @JsonAdapter(RegionEnum.Adapter.class)
  public enum RegionEnum {
    PUBSUB_GOOGLEAPIS_COM("pubsub.googleapis.com"),
    US_EAST1_PUBSUB_GOOGLEAPIS_COM("us-east1-pubsub.googleapis.com"),
    US_EAST4_PUBSUB_GOOGLEAPIS_COM("us-east4-pubsub.googleapis.com"),
    US_CENTRAL1_PUBSUB_GOOGLEAPIS_COM("us-central1-pubsub.googleapis.com"),
    US_CENTRAL2_PUBSUB_GOOGLEAPIS_COM("us-central2-pubsub.googleapis.com"),
    US_WEST1_PUBSUB_GOOGLEAPIS_COM("us-west1-pubsub.googleapis.com"),
    US_WEST2_PUBSUB_GOOGLEAPIS_COM("us-west2-pubsub.googleapis.com"),
    US_WEST3_PUBSUB_GOOGLEAPIS_COM("us-west3-pubsub.googleapis.com"),
    SOUTHAMERICA_EAST1_PUBSUB_GOOGLEAPIS_COM("southamerica-east1-pubsub.googleapis.com"),
    NORTHAMERICA_NORTHEAST1_PUBSUB_GOOGLEAPIS_COM("northamerica-northeast1-pubsub.googleapis.com"),
    EUROPE_WEST6_PUBSUB_GOOGLEAPIS_COM("europe-west6-pubsub.googleapis.com"),
    EUROPE_WEST4_PUBSUB_GOOGLEAPIS_COM("europe-west4-pubsub.googleapis.com"),
    EUROPE_WEST3_PUBSUB_GOOGLEAPIS_COM("europe-west3-pubsub.googleapis.com"),
    EUROPE_WEST2_PUBSUB_GOOGLEAPIS_COM("europe-west2-pubsub.googleapis.com"),
    EUROPE_WEST1_PUBSUB_GOOGLEAPIS_COM("europe-west1-pubsub.googleapis.com"),
    EUROPE_NORTH1_PUBSUB_GOOGLEAPIS_COM("europe-north1-pubsub.googleapis.com"),
    AUSTRALIA_SOUTHEAST1_PUBSUB_GOOGLEAPIS_COM("australia-southeast1-pubsub.googleapis.com"),
    ASIA_SOUTHEAST1_PUBSUB_GOOGLEAPIS_COM("asia-southeast1-pubsub.googleapis.com"),
    ASIA_SOUTH1_PUBSUB_GOOGLEAPIS_COM("asia-south1-pubsub.googleapis.com"),
    ASIA_NORTHEAST3_PUBSUB_GOOGLEAPIS_COM("asia-northeast3-pubsub.googleapis.com"),
    ASIA_NORTHEAST2_PUBSUB_GOOGLEAPIS_COM("asia-northeast2-pubsub.googleapis.com"),
    ASIA_NORTHEAST1_PUBSUB_GOOGLEAPIS_COM("asia-northeast1-pubsub.googleapis.com"),
    ASIA_EAST2_PUBSUB_GOOGLEAPIS_COM("asia-east2-pubsub.googleapis.com"),
    ASIA_EAST1_PUBSUB_GOOGLEAPIS_COM("asia-east1-pubsub.googleapis.com"),
    ASIA("ASIA"),
    EU("EU"),
    US("US"),
    ASIA1("ASIA1"),
    EUR4("EUR4"),
    NAM4("NAM4");

    private String value;

    RegionEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static RegionEnum fromValue(String text) {
      for (RegionEnum b : RegionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<RegionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RegionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RegionEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return RegionEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("region")
  private RegionEnum region = RegionEnum.US;

  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  @JsonAdapter(AwsAuthenticationMethodEnum.Adapter.class)
  public enum AwsAuthenticationMethodEnum {
    MANUAL("manual"),
    SECRET("secret"),
    SECRET_2("secret");

    private String value;

    AwsAuthenticationMethodEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static AwsAuthenticationMethodEnum fromValue(String text) {
      for (AwsAuthenticationMethodEnum b : AwsAuthenticationMethodEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<AwsAuthenticationMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AwsAuthenticationMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AwsAuthenticationMethodEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return AwsAuthenticationMethodEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("awsAuthenticationMethod")
  private AwsAuthenticationMethodEnum awsAuthenticationMethod = AwsAuthenticationMethodEnum.MANUAL;

  @SerializedName("awsSecretKey")
  private String awsSecretKey = null;

  @SerializedName("endpoint")
  private String endpoint = "https://storage.googleapis.com";

  /**
   * Signature version to use for signing Google Cloud Storage requests.
   */
  @JsonAdapter(SignatureVersionEnum.Adapter.class)
  public enum SignatureVersionEnum {
    V2("v2"),
    V4("v4");

    private String value;

    SignatureVersionEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static SignatureVersionEnum fromValue(String text) {
      for (SignatureVersionEnum b : SignatureVersionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<SignatureVersionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SignatureVersionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SignatureVersionEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return SignatureVersionEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("signatureVersion")
  private SignatureVersionEnum signatureVersion = SignatureVersionEnum.V4;

  @SerializedName("reuseConnections")
  private Boolean reuseConnections = true;

  @SerializedName("enableAssumeRole")
  private Boolean enableAssumeRole = false;

  @SerializedName("assumeRoleArn")
  private String assumeRoleArn = null;

  @SerializedName("assumeRoleExternalId")
  private String assumeRoleExternalId = null;

  /**
   * Object ACL to assign to uploaded objects.
   */
  @JsonAdapter(ObjectACLEnum.Adapter.class)
  public enum ObjectACLEnum {
    PRIVATE("private"),
    BUCKET_OWNER_READ("bucket-owner-read"),
    BUCKET_OWNER_FULL_CONTROL("bucket-owner-full-control"),
    PROJECT_PRIVATE("project-private"),
    AUTHENTICATED_READ("authenticated-read"),
    PUBLIC_READ("public-read"),
    BUCKET_OWNER_FULL_CONTROL_6("bucket-owner-full-control");

    private String value;

    ObjectACLEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ObjectACLEnum fromValue(String text) {
      for (ObjectACLEnum b : ObjectACLEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ObjectACLEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ObjectACLEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ObjectACLEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return ObjectACLEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("objectACL")
  private ObjectACLEnum objectACL = ObjectACLEnum.PRIVATE;

  /**
   * Storage class to select for uploaded objects.
   */
  @JsonAdapter(StorageClassEnum.Adapter.class)
  public enum StorageClassEnum {
    STANDARD("STANDARD"),
    NEARLINE("NEARLINE"),
    COLDLINE("COLDLINE"),
    ARCHIVE("ARCHIVE"),
    INTELLIGENT_TIERING("INTELLIGENT_TIERING"),
    GLACIER("GLACIER"),
    DEEP_ARCHIVE("DEEP_ARCHIVE");

    private String value;

    StorageClassEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static StorageClassEnum fromValue(String text) {
      for (StorageClassEnum b : StorageClassEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<StorageClassEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StorageClassEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StorageClassEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return StorageClassEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("storageClass")
  private StorageClassEnum storageClass = null;

  /**
   * Server-side encryption for uploaded objects.
   */
  @JsonAdapter(ServerSideEncryptionEnum.Adapter.class)
  public enum ServerSideEncryptionEnum {
    AES256("AES256"),
    AWS_KMS("aws:kms");

    private String value;

    ServerSideEncryptionEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ServerSideEncryptionEnum fromValue(String text) {
      for (ServerSideEncryptionEnum b : ServerSideEncryptionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ServerSideEncryptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ServerSideEncryptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ServerSideEncryptionEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return ServerSideEncryptionEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("serverSideEncryption")
  private ServerSideEncryptionEnum serverSideEncryption = null;

  @SerializedName("kmsKeyId")
  private Object kmsKeyId = null;

  @SerializedName("containerName")
  private String containerName = null;

  @SerializedName("createContainer")
  private Boolean createContainer = false;

  /**
   * Log type value to send to Chronicle. Can be overwritten by event field __logType.
   */
  @JsonAdapter(LogTypeEnum.Adapter.class)
  public enum LogTypeEnum {
    ABNORMAL_SECURITY("ABNORMAL_SECURITY"),
    ABSOLUTE("ABSOLUTE"),
    ACALVIO("ACALVIO"),
    ACCELLION("ACCELLION"),
    ACTIVE_SYNC("ACTIVE_SYNC"),
    ADAUDIT_PLUS("ADAUDIT_PLUS"),
    ADFS("ADFS"),
    ADMANAGER_PLUS("ADMANAGER_PLUS"),
    AIRWATCH("AIRWATCH"),
    AI_HUNTER("AI_HUNTER"),
    AKAMAI_CLOUD_MONITOR("AKAMAI_CLOUD_MONITOR"),
    AKAMAI_DDOS("AKAMAI_DDOS"),
    AKAMAI_DHCP("AKAMAI_DHCP"),
    AKAMAI_DNS("AKAMAI_DNS"),
    AKAMAI_WAF("AKAMAI_WAF"),
    ALGOSEC("ALGOSEC"),
    ALLOT_NETENFORCER("ALLOT_NETENFORCER"),
    ANOMALI_IOC("ANOMALI_IOC"),
    APACHE("APACHE"),
    APC_SMART_UPS("APC_SMART_UPS"),
    AQUA_SECURITY("AQUA_SECURITY"),
    ARBOR_EDGE_DEFENSE("ARBOR_EDGE_DEFENSE"),
    ARKIME_PCAP("ARKIME_PCAP"),
    ARMIS("ARMIS"),
    ARRAYNETWORKS_VPN("ARRAYNETWORKS_VPN"),
    ARUBA_AIRWAVE("ARUBA_AIRWAVE"),
    ARUBA_WIRELESS("ARUBA_WIRELESS"),
    ASOC_ALERT("ASOC_ALERT"),
    ASSET_STATIC_IP("ASSET_STATIC_IP"),
    ATTIVO("ATTIVO"),
    ATT_NETBOND("ATT_NETBOND"),
    AUDITD("AUDITD"),
    AUTHENTIC8_SILO("AUTHENTIC8_SILO"),
    AUTHX("AUTHX"),
    AUTH_ZERO("AUTH_ZERO"),
    AUTOMATION_ANYWHERE("AUTOMATION_ANYWHERE"),
    AUTOMOX_EPM("AUTOMOX_EPM"),
    AVANAN_EMAIL("AVANAN_EMAIL"),
    AVATIER("AVATIER"),
    AVAYA_WIRELESS("AVAYA_WIRELESS"),
    AWS_CLOUDFRONT("AWS_CLOUDFRONT"),
    AWS_CLOUDTRAIL("AWS_CLOUDTRAIL"),
    AWS_CLOUDWATCH("AWS_CLOUDWATCH"),
    AWS_CONFIG("AWS_CONFIG"),
    AWS_CONTROL_TOWER("AWS_CONTROL_TOWER"),
    AWS_ELB("AWS_ELB"),
    AWS_MACIE("AWS_MACIE"),
    AWS_ROUTE_53("AWS_ROUTE_53"),
    AWS_SECURITY_HUB("AWS_SECURITY_HUB"),
    AWS_SESSION_MANAGER("AWS_SESSION_MANAGER"),
    AWS_VPC_FLOW("AWS_VPC_FLOW"),
    AWS_WAF("AWS_WAF"),
    AZURE("AZURE"),
    AZURE_ACTIVITY("AZURE_ACTIVITY"),
    AZURE_AD("AZURE_AD"),
    AZURE_AD_CONTEXT("AZURE_AD_CONTEXT"),
    AZURE_ATP("AZURE_ATP"),
    AZURE_MDM_INTUNE("AZURE_MDM_INTUNE"),
    AZURE_NSG_FLOW("AZURE_NSG_FLOW"),
    AZURE_RESOURCE_LOGS("AZURE_RESOURCE_LOGS"),
    BARRACUDA_CLOUDGEN_ACCESS("BARRACUDA_CLOUDGEN_ACCESS"),
    BARRACUDA_EMAIL("BARRACUDA_EMAIL"),
    BARRACUDA_WAF("BARRACUDA_WAF"),
    BIGSWITCH_BCF("BIGSWITCH_BCF"),
    BIND_DNS("BIND_DNS"),
    BITDEFENDER("BITDEFENDER"),
    BLUECAT_DDI("BLUECAT_DDI"),
    BLUECOAT_WEBPROXY("BLUECOAT_WEBPROXY"),
    BMC_AMI_DEFENDER("BMC_AMI_DEFENDER"),
    BOMGAR("BOMGAR"),
    BOX("BOX"),
    BRIVO("BRIVO"),
    BROCADE_SERVERIRON("BROCADE_SERVERIRON"),
    BROCADE_SWITCH("BROCADE_SWITCH"),
    BRO_DHCP("BRO_DHCP"),
    BRO_HTTP("BRO_HTTP"),
    BRO_JSON("BRO_JSON"),
    BRO_TSV("BRO_TSV"),
    BT_IPCONTROL("BT_IPCONTROL"),
    CATO_NETWORKS("CATO_NETWORKS"),
    CATO_SDWAN("CATO_SDWAN"),
    CA_ACF2("CA_ACF2"),
    CA_LDAP("CA_LDAP"),
    CA_SSO_WEB("CA_SSO_WEB"),
    CB_APP_CONTROL("CB_APP_CONTROL"),
    CB_EDR("CB_EDR"),
    CENTRIFY_SSO("CENTRIFY_SSO"),
    CENTRIPETAL_IOC("CENTRIPETAL_IOC"),
    CHECKPOINT_EDR("CHECKPOINT_EDR"),
    CHECKPOINT_EMAIL("CHECKPOINT_EMAIL"),
    CHECKPOINT_FIREWALL("CHECKPOINT_FIREWALL"),
    CISCO_ACE("CISCO_ACE"),
    CISCO_ACI("CISCO_ACI"),
    CISCO_ACS("CISCO_ACS"),
    CISCO_AMP("CISCO_AMP"),
    CISCO_ASA_FIREWALL("CISCO_ASA_FIREWALL"),
    CISCO_CTS("CISCO_CTS"),
    CISCO_DHCP("CISCO_DHCP"),
    CISCO_DNS("CISCO_DNS"),
    CISCO_EMAIL_SECURITY("CISCO_EMAIL_SECURITY"),
    CISCO_FIREPOWER_FIREWALL("CISCO_FIREPOWER_FIREWALL"),
    CISCO_FIRESIGHT("CISCO_FIRESIGHT"),
    CISCO_IOS("CISCO_IOS"),
    CISCO_ISE("CISCO_ISE"),
    CISCO_MERAKI("CISCO_MERAKI"),
    CISCO_NX_OS("CISCO_NX_OS"),
    CISCO_PRIME("CISCO_PRIME"),
    CISCO_ROUTER("CISCO_ROUTER"),
    CISCO_SMA("CISCO_SMA"),
    CISCO_SWITCH("CISCO_SWITCH"),
    CISCO_TACACS("CISCO_TACACS"),
    CISCO_UCM("CISCO_UCM"),
    CISCO_UCS("CISCO_UCS"),
    CISCO_VPN("CISCO_VPN"),
    CISCO_WIRELESS("CISCO_WIRELESS"),
    CISCO_WSA("CISCO_WSA"),
    CIS_ALBERT_ALERT("CIS_ALBERT_ALERT"),
    CITRIX_NETSCALER("CITRIX_NETSCALER"),
    CITRIX_NETSCALER_WEB_LOGS("CITRIX_NETSCALER_WEB_LOGS"),
    CITRIX_SDWAN("CITRIX_SDWAN"),
    CITRIX_STOREFRONT("CITRIX_STOREFRONT"),
    CITRIX_WEB_GATEWAY("CITRIX_WEB_GATEWAY"),
    CITRIX_WORKSPACE("CITRIX_WORKSPACE"),
    CLAM_AV("CLAM_AV"),
    CLEARPASS("CLEARPASS"),
    CLOUDFLARE("CLOUDFLARE"),
    CLOUDGENIX_SDWAN("CLOUDGENIX_SDWAN"),
    CLOUDIAN_HYPERSTORE("CLOUDIAN_HYPERSTORE"),
    CLOUDM("CLOUDM"),
    CLOUDPASSAGE_CSM("CLOUDPASSAGE_CSM"),
    CLOUDPASSAGE_FIM("CLOUDPASSAGE_FIM"),
    CLOUDPASSAGE_LIDS("CLOUDPASSAGE_LIDS"),
    CLOUDPASSAGE_SVM("CLOUDPASSAGE_SVM"),
    CLOUD_IDENTITY_CONTEXT("CLOUD_IDENTITY_CONTEXT"),
    CLOUD_PASSAGE("CLOUD_PASSAGE"),
    CMD("CMD"),
    CODE42("CODE42"),
    CODE_WORLDWIDE("CODE_WORLDWIDE"),
    COFENSE_TRIAGE("COFENSE_TRIAGE"),
    COFENSE_VISION("COFENSE_VISION"),
    COHESITY("COHESITY"),
    COMODO_AV("COMODO_AV"),
    CORELIGHT("CORELIGHT"),
    CORTEX_XDR("CORTEX_XDR"),
    COVID_CTC_IOC("COVID_CTC_IOC"),
    CROWDSTRIKE_IOC("CROWDSTRIKE_IOC"),
    CSV_CUSTOM_IOC("CSV_CUSTOM_IOC"),
    CS_CEF_EDR("CS_CEF_EDR"),
    CS_EDR("CS_EDR"),
    CS_STREAM("CS_STREAM"),
    CUSTOMER_ALERT("CUSTOMER_ALERT"),
    CUSTOM_SECURITY_DATA_ANALYTICS("CUSTOM_SECURITY_DATA_ANALYTICS"),
    CYBERARK("CYBERARK"),
    CYBEREASON_EDR("CYBEREASON_EDR"),
    CYLANCE("CYLANCE"),
    CYLANCE_PROTECT("CYLANCE_PROTECT"),
    D3_SECURITY("D3_SECURITY"),
    DARKTRACE("DARKTRACE"),
    DATAWATCH("DATAWATCH"),
    DB2_DB("DB2_DB"),
    DELL_EMC_NAS("DELL_EMC_NAS"),
    DELL_SWITCH("DELL_SWITCH"),
    DHS_IOC("DHS_IOC"),
    DIGITALGUARDIAN_EDR("DIGITALGUARDIAN_EDR"),
    DIGITAL_SHADOWS_IOC("DIGITAL_SHADOWS_IOC"),
    DMP_ENTRE("DMP_ENTRE"),
    DROPBOX("DROPBOX"),
    DUO_AUTH("DUO_AUTH"),
    DUO_CASB("DUO_CASB"),
    DUO_NETWORK_GATEWAY("DUO_NETWORK_GATEWAY"),
    DUO_USER_CONTEXT("DUO_USER_CONTEXT"),
    ECAR("ECAR"),
    ECAR_BRO("ECAR_BRO"),
    EFFICIENTIP_DDI("EFFICIENTIP_DDI"),
    EIQ_EDR("EIQ_EDR"),
    ELASTIC_FILEBEAT("ELASTIC_FILEBEAT"),
    ELASTIC_METRICBEAT("ELASTIC_METRICBEAT"),
    ELASTIC_PACKETBEATS("ELASTIC_PACKETBEATS"),
    ELASTIC_SEARCH("ELASTIC_SEARCH"),
    ELASTIC_WINLOGBEAT("ELASTIC_WINLOGBEAT"),
    ENDGAME_EDR("ENDGAME_EDR"),
    ESET_AV("ESET_AV"),
    ESET_EDR("ESET_EDR"),
    ESET_IOC("ESET_IOC"),
    ET_PRO_IOC("ET_PRO_IOC"),
    EXCHANGE_MAIL("EXCHANGE_MAIL"),
    EXTRAHOP("EXTRAHOP"),
    EXTRAHOP_DHCP("EXTRAHOP_DHCP"),
    EXTRAHOP_DNS("EXTRAHOP_DNS"),
    F5_ASM("F5_ASM"),
    F5_BIGIP_LTM("F5_BIGIP_LTM"),
    F5_DNS("F5_DNS"),
    F5_VPN("F5_VPN"),
    FALCO_IDS("FALCO_IDS"),
    FIDELIS_ENDPOINT("FIDELIS_ENDPOINT"),
    FIDELIS_NETWORK("FIDELIS_NETWORK"),
    FILEZILLA_FTP("FILEZILLA_FTP"),
    FIREEYE_ALERT("FIREEYE_ALERT"),
    FIREEYE_ETP("FIREEYE_ETP"),
    FIREEYE_HX("FIREEYE_HX"),
    FIREEYE_NX("FIREEYE_NX"),
    FLUENTD("FLUENTD"),
    FORCEPOINT_DLP("FORCEPOINT_DLP"),
    FORCEPOINT_WEBPROXY("FORCEPOINT_WEBPROXY"),
    FORESCOUT_NAC("FORESCOUT_NAC"),
    FORSETI("FORSETI"),
    FORTINET_DHCP("FORTINET_DHCP"),
    FORTINET_FIREWALL("FORTINET_FIREWALL"),
    FORTINET_FORTIEDR("FORTINET_FORTIEDR"),
    FORTINET_FORTINAC("FORTINET_FORTINAC"),
    FORTINET_SANDBOX("FORTINET_SANDBOX"),
    FORTINET_WEBPROXY("FORTINET_WEBPROXY"),
    FOX_IT_STIX("FOX_IT_STIX"),
    FREEIPA("FREEIPA"),
    FREERADIUS("FREERADIUS"),
    FRONTLINE_VM("FRONTLINE_VM"),
    FUTUREX_HSM("FUTUREX_HSM"),
    GCP("GCP"),
    GCP_APIGEE("GCP_APIGEE"),
    GCP_CLOUD_NAT("GCP_CLOUD_NAT"),
    GCP_CSCC("GCP_CSCC"),
    GCP_DNS("GCP_DNS"),
    GCP_FIREWALL("GCP_FIREWALL"),
    GCP_THREAT_DETECTION("GCP_THREAT_DETECTION"),
    GCP_VPC_FLOW("GCP_VPC_FLOW"),
    GIGAMON("GIGAMON"),
    GITHUB("GITHUB"),
    GLOBALSCAPE_SFTP("GLOBALSCAPE_SFTP"),
    GLUSTER_FS("GLUSTER_FS"),
    GMAIL_LOGS("GMAIL_LOGS"),
    GREATHORN("GREATHORN"),
    GSUITE_ADMIN("GSUITE_ADMIN"),
    GSUITE_AUDIT("GSUITE_AUDIT"),
    GUARDDUTY("GUARDDUTY"),
    HAPROXY("HAPROXY"),
    HASHICORP("HASHICORP"),
    HITACHI_ID_PAM("HITACHI_ID_PAM"),
    HONEYD("HONEYD"),
    HP_PROCURVE("HP_PROCURVE"),
    IBM_AS400("IBM_AS400"),
    IBM_CICS("IBM_CICS"),
    IBM_MAAS360("IBM_MAAS360"),
    IBM_SWITCH("IBM_SWITCH"),
    IBM_TIVOLI("IBM_TIVOLI"),
    IBM_WEBSPHERE_APP_SERVER("IBM_WEBSPHERE_APP_SERVER"),
    IBM_ZOS("IBM_ZOS"),
    IBOSS_WEBPROXY("IBOSS_WEBPROXY"),
    IDRAC("IDRAC"),
    IIS("IIS"),
    IMPERVA_DB("IMPERVA_DB"),
    IMPERVA_WAF("IMPERVA_WAF"),
    INFOBLOX("INFOBLOX"),
    INFOBLOX_DHCP("INFOBLOX_DHCP"),
    INFOBLOX_DNS("INFOBLOX_DNS"),
    INFOBLOX_LOADBALANCER("INFOBLOX_LOADBALANCER"),
    INFOBLOX_NETMRI("INFOBLOX_NETMRI"),
    INFOBLOX_RPZ("INFOBLOX_RPZ"),
    IPSWITCH_MOVEIT_AUTOMATION("IPSWITCH_MOVEIT_AUTOMATION"),
    IPSWITCH_MOVEIT_TRANSFER("IPSWITCH_MOVEIT_TRANSFER"),
    IPSWITCH_SFTP("IPSWITCH_SFTP"),
    ISC_DHCP("ISC_DHCP"),
    JAMF("JAMF"),
    JUMPCLOUD_DAAS("JUMPCLOUD_DAAS"),
    JUNIPER_FIREWALL("JUNIPER_FIREWALL"),
    JUNIPER_IPS("JUNIPER_IPS"),
    JUNIPER_MX("JUNIPER_MX"),
    KASEYA("KASEYA"),
    KASPERSKY_AV("KASPERSKY_AV"),
    KEA_DHCP("KEA_DHCP"),
    KEEPER("KEEPER"),
    KEMP_LOADBALANCER("KEMP_LOADBALANCER"),
    KNOWBE4_PHISHER("KNOWBE4_PHISHER"),
    KUBERNETES_AUTH_PROXY("KUBERNETES_AUTH_PROXY"),
    KUBERNETES_NODE("KUBERNETES_NODE"),
    KYRIBA("KYRIBA"),
    LACEWORK("LACEWORK"),
    LIMACHARLIE_EDR("LIMACHARLIE_EDR"),
    LINUX_DHCP("LINUX_DHCP"),
    LOGICMONITOR("LOGICMONITOR"),
    LOOKINGGLASS_IPS("LOOKINGGLASS_IPS"),
    LOOKING_GLASS_IOC("LOOKING_GLASS_IOC"),
    MALWAREBYTES_EDR("MALWAREBYTES_EDR"),
    MANGOAPPS("MANGOAPPS"),
    MATERIAL_SECURITY("MATERIAL_SECURITY"),
    MCAFEE_DLP("MCAFEE_DLP"),
    MCAFEE_EDR("MCAFEE_EDR"),
    MCAFEE_EPO("MCAFEE_EPO"),
    MCAFEE_ESM("MCAFEE_ESM"),
    MCAFEE_IPS("MCAFEE_IPS"),
    MCAFEE_MVISION_CASB("MCAFEE_MVISION_CASB"),
    MCAFEE_UCE("MCAFEE_UCE"),
    MCAFEE_WEBPROXY("MCAFEE_WEBPROXY"),
    MCAFEE_WEB_PROTECTION("MCAFEE_WEB_PROTECTION"),
    MEDIGATE_CMDB("MEDIGATE_CMDB"),
    MEDIGATE_IOT("MEDIGATE_IOT"),
    MENLO_SECURITY("MENLO_SECURITY"),
    MICROSOFT_ATA("MICROSOFT_ATA"),
    MICROSOFT_CASB("MICROSOFT_CASB"),
    MICROSOFT_GRAPH_ALERT("MICROSOFT_GRAPH_ALERT"),
    MICROSOFT_SCEP("MICROSOFT_SCEP"),
    MICROSOFT_SECURITY_CENTER_ALERT("MICROSOFT_SECURITY_CENTER_ALERT"),
    MICROSOFT_SQL("MICROSOFT_SQL"),
    MIMECAST_MAIL("MIMECAST_MAIL"),
    MIMECAST_WEBPROXY("MIMECAST_WEBPROXY"),
    MINERVA_AV("MINERVA_AV"),
    MISP_IOC("MISP_IOC"),
    MONGO_DB("MONGO_DB"),
    MULESOFT("MULESOFT"),
    MYSQL("MYSQL"),
    NAGIOS("NAGIOS"),
    NASUNI_FILE_SERVICES("NASUNI_FILE_SERVICES"),
    NCR_DIGITAL_INSIGHT_FSG("NCR_DIGITAL_INSIGHT_FSG"),
    NCR_DIGITAL_INSIGHT_GL("NCR_DIGITAL_INSIGHT_GL"),
    NETAPP_SAN("NETAPP_SAN"),
    NETDISCO("NETDISCO"),
    NETMOTION("NETMOTION"),
    NETSKOPE_ALERT("NETSKOPE_ALERT"),
    NETSKOPE_WEBPROXY("NETSKOPE_WEBPROXY"),
    NGINX("NGINX"),
    NIMBLE_OS("NIMBLE_OS"),
    NIX_SYSTEM("NIX_SYSTEM"),
    NUCLEUS_ASSET("NUCLEUS_ASSET"),
    NUCLEUS_VULNERABILITY("NUCLEUS_VULNERABILITY"),
    NUCLEUS_VULNERABILITY_DELTA("NUCLEUS_VULNERABILITY_DELTA"),
    NUTANIX_PRISM("NUTANIX_PRISM"),
    OBSERVEIT("OBSERVEIT"),
    OBSIDIAN("OBSIDIAN"),
    OFFICE_365("OFFICE_365"),
    OKTA("OKTA"),
    OKTA_ACCESS_GATEWAY("OKTA_ACCESS_GATEWAY"),
    OKTA_USER_CONTEXT("OKTA_USER_CONTEXT"),
    ONBASE_CMS("ONBASE_CMS"),
    ONEIDENTITY_ARS("ONEIDENTITY_ARS"),
    ONEIDENTITY_CHANGE_AUDITOR("ONEIDENTITY_CHANGE_AUDITOR"),
    ONEIDENTITY_DEFENDER("ONEIDENTITY_DEFENDER"),
    ONEIDENTITY_TPAM("ONEIDENTITY_TPAM"),
    ONELOGIN_SSO("ONELOGIN_SSO"),
    OPENAM("OPENAM"),
    OPENDJ("OPENDJ"),
    OPENGEAR("OPENGEAR"),
    OPENPATH("OPENPATH"),
    OPENSSH("OPENSSH"),
    OPEN_VPN("OPEN_VPN"),
    ORACLE_DB("ORACLE_DB"),
    ORDR_IOT("ORDR_IOT"),
    OSINT_IOC("OSINT_IOC"),
    OSQUERY_EDR("OSQUERY_EDR"),
    OSSEC("OSSEC"),
    PAN_CASB("PAN_CASB"),
    PAN_EDR("PAN_EDR"),
    PAN_FIREWALL("PAN_FIREWALL"),
    PAN_IOC("PAN_IOC"),
    PAN_PRISMA_CLOUD("PAN_PRISMA_CLOUD"),
    PASSIVE_DNS("PASSIVE_DNS"),
    PCAP_SSL_CLIENT_HELLO("PCAP_SSL_CLIENT_HELLO"),
    PEOPLESOFT("PEOPLESOFT"),
    PEPLINK_LOADBALANCER("PEPLINK_LOADBALANCER"),
    PEPLINK_ROUTER("PEPLINK_ROUTER"),
    PEPLINK_SWITCH("PEPLINK_SWITCH"),
    PERIMETERX_BOT_PROTECTION("PERIMETERX_BOT_PROTECTION"),
    PFSENSE("PFSENSE"),
    PHISHEYE_ALERT("PHISHEYE_ALERT"),
    PING("PING"),
    PIVOTAL("PIVOTAL"),
    PLIXER_SCRUTINIZER("PLIXER_SCRUTINIZER"),
    POSTFIX_MAIL("POSTFIX_MAIL"),
    POWERSHELL("POWERSHELL"),
    POWER_DNS("POWER_DNS"),
    PREEMPT("PREEMPT"),
    PREEMPT_AUTH("PREEMPT_AUTH"),
    PROOFID("PROOFID"),
    PROOFPOINT_CASB("PROOFPOINT_CASB"),
    PROOFPOINT_MAIL("PROOFPOINT_MAIL"),
    PROOFPOINT_MAIL_FILTER("PROOFPOINT_MAIL_FILTER"),
    PROOFPOINT_ON_DEMAND("PROOFPOINT_ON_DEMAND"),
    PROOFPOINT_TRAP("PROOFPOINT_TRAP"),
    PROOFPOINT_WEB_BROWSER_ISOLATION("PROOFPOINT_WEB_BROWSER_ISOLATION"),
    PROWATCH("PROWATCH"),
    PULSE_SECURE_VPN("PULSE_SECURE_VPN"),
    QUALYS_CONTINUOUS_MONITORING("QUALYS_CONTINUOUS_MONITORING"),
    QUALYS_VM("QUALYS_VM"),
    RADIUS("RADIUS"),
    RADWARE_FIREWALL("RADWARE_FIREWALL"),
    RAPID7_INSIGHT("RAPID7_INSIGHT"),
    RAPID7_NEXPOSE("RAPID7_NEXPOSE"),
    RECORDED_FUTURE_IOC("RECORDED_FUTURE_IOC"),
    REDCANARY_CLOUD_PROTECTION_RAW("REDCANARY_CLOUD_PROTECTION_RAW"),
    REDCANARY_EDR("REDCANARY_EDR"),
    RH_ISAC_IOC("RH_ISAC_IOC"),
    RING_CENTRAL("RING_CENTRAL"),
    RISKIQ_DIGITAL_FOOTPRINT("RISKIQ_DIGITAL_FOOTPRINT"),
    RSA_AUTH_MANAGER("RSA_AUTH_MANAGER"),
    SAFECONNECT_NAC("SAFECONNECT_NAC"),
    SAILPOINT_IAM("SAILPOINT_IAM"),
    SALESFORCE("SALESFORCE"),
    SECUREAUTH_SSO("SECUREAUTH_SSO"),
    SECURELINK("SECURELINK"),
    SEMPERIS_ADFR("SEMPERIS_ADFR"),
    SEMPERIS_DSP("SEMPERIS_DSP"),
    SENDMAIL("SENDMAIL"),
    SENTINEL_DV("SENTINEL_DV"),
    SENTINEL_EDR("SENTINEL_EDR"),
    SEP("SEP"),
    SERVICENOW_CMDB("SERVICENOW_CMDB"),
    SERVICENOW_SECURITY("SERVICENOW_SECURITY"),
    SHAREPOINT("SHAREPOINT"),
    SHIBBOLETH_IDP("SHIBBOLETH_IDP"),
    SHODAN_IO("SHODAN_IO"),
    SIGNAL_SCIENCES_WAF("SIGNAL_SCIENCES_WAF"),
    SITEMINDER_SSO("SITEMINDER_SSO"),
    SLACK_AUDIT("SLACK_AUDIT"),
    SNIPE_IT("SNIPE_IT"),
    SNORT_IDS("SNORT_IDS"),
    SONIC_FIREWALL("SONIC_FIREWALL"),
    SOPHOS_AV("SOPHOS_AV"),
    SOPHOS_DHCP("SOPHOS_DHCP"),
    SOPHOS_UTM("SOPHOS_UTM"),
    SOURCEFIRE_IDS("SOURCEFIRE_IDS"),
    SPLUNK_DNS("SPLUNK_DNS"),
    SQUID_WEBPROXY("SQUID_WEBPROXY"),
    STEALTHBITS_AUDIT("STEALTHBITS_AUDIT"),
    STEALTHBITS_DEFEND("STEALTHBITS_DEFEND"),
    STEELHEAD("STEELHEAD"),
    STREAMALERT("STREAMALERT"),
    STRONGSWAN_VPN("STRONGSWAN_VPN"),
    SURICATA_EVE("SURICATA_EVE"),
    SURICATA_IDS("SURICATA_IDS"),
    SYMANTEC_CASB("SYMANTEC_CASB"),
    SYMANTEC_DLP("SYMANTEC_DLP"),
    SYMANTEC_EDR("SYMANTEC_EDR"),
    SYMANTEC_MAIL("SYMANTEC_MAIL"),
    SYMANTEC_VIP("SYMANTEC_VIP"),
    SYMANTEC_WEB_ISOLATION("SYMANTEC_WEB_ISOLATION"),
    SYMANTEC_WSS("SYMANTEC_WSS"),
    TANIUM_ASSET("TANIUM_ASSET"),
    TANIUM_AUDIT("TANIUM_AUDIT"),
    TANIUM_DISCOVER("TANIUM_DISCOVER"),
    TANIUM_INSIGHT("TANIUM_INSIGHT"),
    TANIUM_PATCH("TANIUM_PATCH"),
    TANIUM_QUESTION("TANIUM_QUESTION"),
    TANIUM_REVEAL("TANIUM_REVEAL"),
    TANIUM_TH("TANIUM_TH"),
    TANIUM_THREAT_RESPONSE("TANIUM_THREAT_RESPONSE"),
    TENABLE_IO("TENABLE_IO"),
    TENABLE_SC("TENABLE_SC"),
    TGDETECT("TGDETECT"),
    THALES_MFA("THALES_MFA"),
    THINKST_CANARY("THINKST_CANARY"),
    THYCOTIC("THYCOTIC"),
    THYCOTIC_DEVOPS_SECRETVAULT("THYCOTIC_DEVOPS_SECRETVAULT"),
    TIPPING_POINT("TIPPING_POINT"),
    TOMCAT("TOMCAT"),
    TRENDMICRO_AV("TRENDMICRO_AV"),
    TRENDMICRO_EDR("TRENDMICRO_EDR"),
    TRENDMICRO_WEBPROXY("TRENDMICRO_WEBPROXY"),
    TRIPWIRE_FIM("TRIPWIRE_FIM"),
    UDM("UDM"),
    ULTRADNS("ULTRADNS"),
    UMBRELLA_DNS("UMBRELLA_DNS"),
    UMBRELLA_FIREWALL("UMBRELLA_FIREWALL"),
    UMBRELLA_IP("UMBRELLA_IP"),
    UMBRELLA_WEBPROXY("UMBRELLA_WEBPROXY"),
    UNBOUND_DNS("UNBOUND_DNS"),
    UPTYCS_EDR("UPTYCS_EDR"),
    VANDYKE_SFTP("VANDYKE_SFTP"),
    VARONIS("VARONIS"),
    VECTRA_DETECT("VECTRA_DETECT"),
    VECTRA_STREAM("VECTRA_STREAM"),
    VEEAM("VEEAM"),
    VERIZON_NDR("VERIZON_NDR"),
    VITALQIP("VITALQIP"),
    VMRAY_FLOG_XML("VMRAY_FLOG_XML"),
    VMWARE_AVINETWORKS_IWAF("VMWARE_AVINETWORKS_IWAF"),
    VMWARE_ESX("VMWARE_ESX"),
    VMWARE_VCENTER("VMWARE_VCENTER"),
    VMWARE_VSHIELD("VMWARE_VSHIELD"),
    VORMETRIC("VORMETRIC"),
    WATCHGUARD("WATCHGUARD"),
    WAZUH("WAZUH"),
    WHITECLOUD_EDR("WHITECLOUD_EDR"),
    WINDOWS_AD("WINDOWS_AD"),
    WINDOWS_APPLOCKER("WINDOWS_APPLOCKER"),
    WINDOWS_DEFENDER_ATP("WINDOWS_DEFENDER_ATP"),
    WINDOWS_DEFENDER_AV("WINDOWS_DEFENDER_AV"),
    WINDOWS_DHCP("WINDOWS_DHCP"),
    WINDOWS_DNS("WINDOWS_DNS"),
    WINDOWS_NET_POLICY_SERVER("WINDOWS_NET_POLICY_SERVER"),
    WINDOWS_SYSMON("WINDOWS_SYSMON"),
    WINEVTLOG("WINEVTLOG"),
    WINEVTLOG_XML("WINEVTLOG_XML"),
    WORKDAY("WORKDAY"),
    WORKDAY_AUDIT("WORKDAY_AUDIT"),
    WP_ENGINE("WP_ENGINE"),
    ZSCALER_DNS("ZSCALER_DNS"),
    ZSCALER_FIREWALL("ZSCALER_FIREWALL"),
    ZSCALER_VPN("ZSCALER_VPN"),
    ZSCALER_WEBPROXY("ZSCALER_WEBPROXY");

    private String value;

    LogTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static LogTypeEnum fromValue(String text) {
      for (LogTypeEnum b : LogTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<LogTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LogTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LogTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return LogTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("logType")
  private LogTypeEnum logType = ;

  @SerializedName("resourceId")
  private String resourceId = null;

  @SerializedName("streamName")
  private String streamName = null;

  @SerializedName("maxRecordSizeKB")
  private BigDecimal maxRecordSizeKB = new BigDecimal(256);

  @SerializedName("dataset")
  private String dataset = null;

  @SerializedName("messageField")
  private String messageField = "";

  @SerializedName("metadata")
  private List<OutputDefaultMetadata> metadata = null;

  @SerializedName("accountId")
  private String accountId = null;

  @SerializedName("eventType")
  private String eventType = null;

  @SerializedName("index")
  private String index = null;

  @SerializedName("docType")
  private String docType = null;

  @SerializedName("auth")
  private OutputDefaultAuth auth = null;

  /**
   * Optional Elasticsearch version, used to format events. If not specified, will auto-discover version.
   */
  @JsonAdapter(ElasticVersionEnum.Adapter.class)
  public enum ElasticVersionEnum {
    AUTO("auto"),
    _6("6"),
    _7("7");

    private String value;

    ElasticVersionEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ElasticVersionEnum fromValue(String text) {
      for (ElasticVersionEnum b : ElasticVersionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ElasticVersionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ElasticVersionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ElasticVersionEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return ElasticVersionEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("elasticVersion")
  private ElasticVersionEnum elasticVersion = ElasticVersionEnum.AUTO;

  @SerializedName("brokers")
  private List<String> brokers = null;

  @SerializedName("topic")
  private String topic = null;

  /**
   * Control the number of required acknowledgments
   */
  @JsonAdapter(AckEnum.Adapter.class)
  public enum AckEnum {
    NUMBER_1(new BigDecimal(1)),
    NUMBER_0(new BigDecimal(0)),
    NUMBER_MINUS_1(new BigDecimal(-1));

    private BigDecimal value;

    AckEnum(BigDecimal value) {
      this.value = value;
    }
    public BigDecimal getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static AckEnum fromValue(String text) {
      for (AckEnum b : AckEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<AckEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AckEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AckEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return AckEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("ack")
  private AckEnum ack = new BigDecimal(1);

  @SerializedName("flushEventCount")
  private BigDecimal flushEventCount = new BigDecimal(1000);

  @SerializedName("kafkaSchemaRegistry")
  private KafkaSchemaRegistryAuthentication kafkaSchemaRegistry = null;

  @SerializedName("sasl")
  private Authentication sasl = null;

  @SerializedName("database")
  private String database = null;

  /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   */
  @JsonAdapter(TimestampPrecisionEnum.Adapter.class)
  public enum TimestampPrecisionEnum {
    NS("ns"),
    U("u"),
    MS("ms"),
    S("s"),
    M("m"),
    H("h");

    private String value;

    TimestampPrecisionEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TimestampPrecisionEnum fromValue(String text) {
      for (TimestampPrecisionEnum b : TimestampPrecisionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TimestampPrecisionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TimestampPrecisionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TimestampPrecisionEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return TimestampPrecisionEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("timestampPrecision")
  private TimestampPrecisionEnum timestampPrecision = TimestampPrecisionEnum.MS;

  @SerializedName("dynamicValueFieldName")
  private Boolean dynamicValueFieldName = true;

  @SerializedName("valueFieldName")
  private String valueFieldName = "value";

  @SerializedName("logGroupName")
  private String logGroupName = null;

  @SerializedName("logStreamName")
  private String logStreamName = null;

  @SerializedName("maxQueueSize")
  private BigDecimal maxQueueSize = new BigDecimal(100);

  @SerializedName("mtu")
  private BigDecimal mtu = new BigDecimal(512);

  @SerializedName("rules")
  private List<NotificationTargetRouterRules> rules = null;

  @SerializedName("queueName")
  private String queueName = null;

  /**
   * The queue type used (or created). Defaults to Standard.
   */
  @JsonAdapter(QueueTypeEnum.Adapter.class)
  public enum QueueTypeEnum {
    STANDARD("standard"),
    FIFO("fifo");

    private String value;

    QueueTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static QueueTypeEnum fromValue(String text) {
      for (QueueTypeEnum b : QueueTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<QueueTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final QueueTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public QueueTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return QueueTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("queueType")
  private QueueTypeEnum queueType = QueueTypeEnum.STANDARD;

  @SerializedName("awsAccountId")
  private String awsAccountId = null;

  @SerializedName("messageGroupId")
  private String messageGroupId = "cribl";

  @SerializedName("createQueue")
  private Boolean createQueue = true;

  @SerializedName("maxInProgress")
  private BigDecimal maxInProgress = new BigDecimal(10);

  @SerializedName("hosts")
  private List<OutputDefaultHosts> hosts = null;

  @SerializedName("customSource")
  private String customSource = null;

  @SerializedName("customCategory")
  private String customCategory = null;

  /**
   * The content type to use when sending logs.
   */
  @JsonAdapter(ContentTypeEnum.Adapter.class)
  public enum ContentTypeEnum {
    TEXT("text"),
    JSON("json");

    private String value;

    ContentTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ContentTypeEnum fromValue(String text) {
      for (ContentTypeEnum b : ContentTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ContentTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ContentTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ContentTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return ContentTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("contentType")
  private ContentTypeEnum contentType = ContentTypeEnum.JSON;

  @SerializedName("message")
  private String message = null;

  @SerializedName("source")
  private String source = null;

  @SerializedName("service")
  private String service = null;

  @SerializedName("tags")
  private List<String> tags = null;

  @SerializedName("metricRenameExpr")
  private String metricRenameExpr = "name.replace(/\\./g, '_')";

  @SerializedName("sendMetadata")
  private Boolean sendMetadata = true;

  /**
   * The method to use when sending events. Defaults to POST.
   */
  @JsonAdapter(MethodEnum.Adapter.class)
  public enum MethodEnum {
    POST("POST"),
    PUT("PUT"),
    PATCH("PATCH");

    private String value;

    MethodEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static MethodEnum fromValue(String text) {
      for (MethodEnum b : MethodEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<MethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MethodEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return MethodEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("method")
  private MethodEnum method = MethodEnum.POST;

  @SerializedName("topicName")
  private String topicName = null;

  @SerializedName("createTopic")
  private Boolean createTopic = false;

  @SerializedName("orderedDelivery")
  private Boolean orderedDelivery = false;

  /**
   * Google authentication method. Choose Auto to use environment variables PUBSUB_PROJECT and PUBSUB_CREDENTIALS.
   */
  @JsonAdapter(GoogleAuthMethodEnum.Adapter.class)
  public enum GoogleAuthMethodEnum {
    AUTO("auto"),
    MANUAL("manual"),
    SECRET("secret");

    private String value;

    GoogleAuthMethodEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static GoogleAuthMethodEnum fromValue(String text) {
      for (GoogleAuthMethodEnum b : GoogleAuthMethodEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<GoogleAuthMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final GoogleAuthMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public GoogleAuthMethodEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return GoogleAuthMethodEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("googleAuthMethod")
  private GoogleAuthMethodEnum googleAuthMethod = GoogleAuthMethodEnum.MANUAL;

  @SerializedName("serviceAccountCredentials")
  private Object serviceAccountCredentials = null;

  @SerializedName("secret")
  private Object secret = null;

  @SerializedName("batchSize")
  private BigDecimal batchSize = new BigDecimal(10);

  @SerializedName("batchTimeout")
  private BigDecimal batchTimeout = new BigDecimal(100);

  /**
   * Gets or Sets authenticationMethod
   */
  @JsonAdapter(AuthenticationMethodEnum.Adapter.class)
  public enum AuthenticationMethodEnum {
    MANUAL("manual"),
    SECRET("secret");

    private String value;

    AuthenticationMethodEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static AuthenticationMethodEnum fromValue(String text) {
      for (AuthenticationMethodEnum b : AuthenticationMethodEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<AuthenticationMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AuthenticationMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AuthenticationMethodEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return AuthenticationMethodEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("authenticationMethod")
  private AuthenticationMethodEnum authenticationMethod = AuthenticationMethodEnum.MANUAL;

  @SerializedName("logTextField")
  private String logTextField = null;

  /**
   * Gets or Sets logFormatType
   */
  @JsonAdapter(LogFormatTypeEnum.Adapter.class)
  public enum LogFormatTypeEnum {
    UNSTRUCTURED("unstructured"),
    UDM("udm");

    private String value;

    LogFormatTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static LogFormatTypeEnum fromValue(String text) {
      for (LogFormatTypeEnum b : LogFormatTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<LogFormatTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LogFormatTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LogFormatTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return LogFormatTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("logFormatType")
  private LogFormatTypeEnum logFormatType = LogFormatTypeEnum.UNSTRUCTURED;

  @SerializedName("lokiUrl")
  private String lokiUrl = null;

  @SerializedName("prometheusUrl")
  private String prometheusUrl = null;

  @SerializedName("labels")
  private List<OutputDefaultLabels> labels = null;

  @SerializedName("prometheusAuth")
  private OutputDefaultPrometheusAuth prometheusAuth = null;

  @SerializedName("lokiAuth")
  private OutputDefaultPrometheusAuth lokiAuth = null;

  public OutputHoneycomb id(String id) {
    this.id = id;
    return this;
  }

   /**
   * Unique ID for this output
   * @return id
  **/
  @Schema(description = "Unique ID for this output")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public OutputHoneycomb type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * Get type
   * @return type
  **/
  @Schema(description = "")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public OutputHoneycomb pipeline(String pipeline) {
    this.pipeline = pipeline;
    return this;
  }

   /**
   * Pipeline to process data before sending out to this output.
   * @return pipeline
  **/
  @Schema(description = "Pipeline to process data before sending out to this output.")
  public String getPipeline() {
    return pipeline;
  }

  public void setPipeline(String pipeline) {
    this.pipeline = pipeline;
  }

  public OutputHoneycomb systemFields(List<String> systemFields) {
    this.systemFields = systemFields;
    return this;
  }

  public OutputHoneycomb addSystemFieldsItem(String systemFieldsItem) {
    if (this.systemFields == null) {
      this.systemFields = new ArrayList<>();
    }
    this.systemFields.add(systemFieldsItem);
    return this;
  }

   /**
   * Set of fields to automatically add to events using this output. E.g.: cribl_pipe, c*. Wildcards supported. These fields are added as labels to generated logs.
   * @return systemFields
  **/
  @Schema(description = "Set of fields to automatically add to events using this output. E.g.: cribl_pipe, c*. Wildcards supported. These fields are added as labels to generated logs.")
  public List<String> getSystemFields() {
    return systemFields;
  }

  public void setSystemFields(List<String> systemFields) {
    this.systemFields = systemFields;
  }

  public OutputHoneycomb defaultId(String defaultId) {
    this.defaultId = defaultId;
    return this;
  }

   /**
   * ID of the default output. This will be used whenever a nonexistent/deleted output is referenced.
   * @return defaultId
  **/
  @Schema(description = "ID of the default output. This will be used whenever a nonexistent/deleted output is referenced.")
  public String getDefaultId() {
    return defaultId;
  }

  public void setDefaultId(String defaultId) {
    this.defaultId = defaultId;
  }

  public OutputHoneycomb host(String host) {
    this.host = host;
    return this;
  }

   /**
   * Name of the host to send with logs. When you send logs as JSON objects, the event&#x27;s &#x27;host&#x27; field (if set) will override this value.
   * @return host
  **/
  @Schema(description = "Name of the host to send with logs. When you send logs as JSON objects, the event's 'host' field (if set) will override this value.")
  public String getHost() {
    return host;
  }

  public void setHost(String host) {
    this.host = host;
  }

  public OutputHoneycomb port(BigDecimal port) {
    this.port = port;
    return this;
  }

   /**
   * Destination port.
   * minimum: 1
   * maximum: 65535
   * @return port
  **/
  @Schema(description = "Destination port.")
  public BigDecimal getPort() {
    return port;
  }

  public void setPort(BigDecimal port) {
    this.port = port;
  }

  public OutputHoneycomb compression(CompressionEnum compression) {
    this.compression = compression;
    return this;
  }

   /**
   * Codec to use to compress the data before sending to Kafka.
   * @return compression
  **/
  @Schema(description = "Codec to use to compress the data before sending to Kafka.")
  public CompressionEnum getCompression() {
    return compression;
  }

  public void setCompression(CompressionEnum compression) {
    this.compression = compression;
  }

  public OutputHoneycomb throttleRatePerSec(String throttleRatePerSec) {
    this.throttleRatePerSec = throttleRatePerSec;
    return this;
  }

   /**
   * Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
   * @return throttleRatePerSec
  **/
  @Schema(description = "Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.")
  public String getThrottleRatePerSec() {
    return throttleRatePerSec;
  }

  public void setThrottleRatePerSec(String throttleRatePerSec) {
    this.throttleRatePerSec = throttleRatePerSec;
  }

  public OutputHoneycomb tls(TLSSettingsClientSide tls) {
    this.tls = tls;
    return this;
  }

   /**
   * Get tls
   * @return tls
  **/
  @Schema(description = "")
  public TLSSettingsClientSide getTls() {
    return tls;
  }

  public void setTls(TLSSettingsClientSide tls) {
    this.tls = tls;
  }

  public OutputHoneycomb connectionTimeout(BigDecimal connectionTimeout) {
    this.connectionTimeout = connectionTimeout;
    return this;
  }

   /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   * @return connectionTimeout
  **/
  @Schema(description = "Amount of time (milliseconds) to wait for the connection to establish before retrying")
  public BigDecimal getConnectionTimeout() {
    return connectionTimeout;
  }

  public void setConnectionTimeout(BigDecimal connectionTimeout) {
    this.connectionTimeout = connectionTimeout;
  }

  public OutputHoneycomb writeTimeout(BigDecimal writeTimeout) {
    this.writeTimeout = writeTimeout;
    return this;
  }

   /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   * @return writeTimeout
  **/
  @Schema(description = "Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead")
  public BigDecimal getWriteTimeout() {
    return writeTimeout;
  }

  public void setWriteTimeout(BigDecimal writeTimeout) {
    this.writeTimeout = writeTimeout;
  }

  public OutputHoneycomb onBackpressure(OnBackpressureEnum onBackpressure) {
    this.onBackpressure = onBackpressure;
    return this;
  }

   /**
   * Whether to block, drop, or queue events when all receivers in this group are exerting backpressure.
   * @return onBackpressure
  **/
  @Schema(description = "Whether to block, drop, or queue events when all receivers in this group are exerting backpressure.")
  public OnBackpressureEnum getOnBackpressure() {
    return onBackpressure;
  }

  public void setOnBackpressure(OnBackpressureEnum onBackpressure) {
    this.onBackpressure = onBackpressure;
  }

  public OutputHoneycomb authType(AuthTypeEnum authType) {
    this.authType = authType;
    return this;
  }

   /**
   * The authentication method to use for the HTTP requests
   * @return authType
  **/
  @Schema(description = "The authentication method to use for the HTTP requests")
  public AuthTypeEnum getAuthType() {
    return authType;
  }

  public void setAuthType(AuthTypeEnum authType) {
    this.authType = authType;
  }

  public OutputHoneycomb protocol(ProtocolEnum protocol) {
    this.protocol = protocol;
    return this;
  }

   /**
   * Protocol to use when communicating with the destination.
   * @return protocol
  **/
  @Schema(description = "Protocol to use when communicating with the destination.")
  public ProtocolEnum getProtocol() {
    return protocol;
  }

  public void setProtocol(ProtocolEnum protocol) {
    this.protocol = protocol;
  }

  public OutputHoneycomb facility(FacilityEnum facility) {
    this.facility = facility;
    return this;
  }

   /**
   * Default value for message facility, will be overwritten by value of __facility if set. Defaults to user.
   * @return facility
  **/
  @Schema(description = "Default value for message facility, will be overwritten by value of __facility if set. Defaults to user.")
  public FacilityEnum getFacility() {
    return facility;
  }

  public void setFacility(FacilityEnum facility) {
    this.facility = facility;
  }

  public OutputHoneycomb severity(SeverityEnum severity) {
    this.severity = severity;
    return this;
  }

   /**
   * Default value for message severity. When you send logs as JSON objects, the event&#x27;s &#x27;__severity&#x27; field (if set) will override this value.
   * @return severity
  **/
  @Schema(description = "Default value for message severity. When you send logs as JSON objects, the event's '__severity' field (if set) will override this value.")
  public SeverityEnum getSeverity() {
    return severity;
  }

  public void setSeverity(SeverityEnum severity) {
    this.severity = severity;
  }

  public OutputHoneycomb appName(String appName) {
    this.appName = appName;
    return this;
  }

   /**
   * Default value for application name, will be overwritten by value of __appname if set. Defaults to Cribl.
   * @return appName
  **/
  @Schema(description = "Default value for application name, will be overwritten by value of __appname if set. Defaults to Cribl.")
  public String getAppName() {
    return appName;
  }

  public void setAppName(String appName) {
    this.appName = appName;
  }

  public OutputHoneycomb messageFormat(MessageFormatEnum messageFormat) {
    this.messageFormat = messageFormat;
    return this;
  }

   /**
   * Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf.
   * @return messageFormat
  **/
  @Schema(description = "Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf.")
  public MessageFormatEnum getMessageFormat() {
    return messageFormat;
  }

  public void setMessageFormat(MessageFormatEnum messageFormat) {
    this.messageFormat = messageFormat;
  }

  public OutputHoneycomb timestampFormat(TimestampFormatEnum timestampFormat) {
    this.timestampFormat = timestampFormat;
    return this;
  }

   /**
   * Timestamp format to use when serializing event&#x27;s time field
   * @return timestampFormat
  **/
  @Schema(description = "Timestamp format to use when serializing event's time field")
  public TimestampFormatEnum getTimestampFormat() {
    return timestampFormat;
  }

  public void setTimestampFormat(TimestampFormatEnum timestampFormat) {
    this.timestampFormat = timestampFormat;
  }

  public OutputHoneycomb nestedFields(NestedFieldsEnum nestedFields) {
    this.nestedFields = nestedFields;
    return this;
  }

   /**
   * Specifies how to serialize nested fields into index-time fields.
   * @return nestedFields
  **/
  @Schema(description = "Specifies how to serialize nested fields into index-time fields.")
  public NestedFieldsEnum getNestedFields() {
    return nestedFields;
  }

  public void setNestedFields(NestedFieldsEnum nestedFields) {
    this.nestedFields = nestedFields;
  }

  public OutputHoneycomb enableMultiMetrics(Boolean enableMultiMetrics) {
    this.enableMultiMetrics = enableMultiMetrics;
    return this;
  }

   /**
   * Output metrics in multiple-metric format, supported in Splunk 8.0 and above to allow multiple metrics in a single event.
   * @return enableMultiMetrics
  **/
  @Schema(description = "Output metrics in multiple-metric format, supported in Splunk 8.0 and above to allow multiple metrics in a single event.")
  public Boolean isEnableMultiMetrics() {
    return enableMultiMetrics;
  }

  public void setEnableMultiMetrics(Boolean enableMultiMetrics) {
    this.enableMultiMetrics = enableMultiMetrics;
  }

  public OutputHoneycomb enableACK(Boolean enableACK) {
    this.enableACK = enableACK;
    return this;
  }

   /**
   * Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.
   * @return enableACK
  **/
  @Schema(description = "Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.")
  public Boolean isEnableACK() {
    return enableACK;
  }

  public void setEnableACK(Boolean enableACK) {
    this.enableACK = enableACK;
  }

  public OutputHoneycomb dnsResolvePeriodSec(BigDecimal dnsResolvePeriodSec) {
    this.dnsResolvePeriodSec = dnsResolvePeriodSec;
    return this;
  }

   /**
   * Re-resolve any hostnames every this many seconds and pick up destinations from A records.
   * minimum: 0
   * maximum: 86400
   * @return dnsResolvePeriodSec
  **/
  @Schema(description = "Re-resolve any hostnames every this many seconds and pick up destinations from A records.")
  public BigDecimal getDnsResolvePeriodSec() {
    return dnsResolvePeriodSec;
  }

  public void setDnsResolvePeriodSec(BigDecimal dnsResolvePeriodSec) {
    this.dnsResolvePeriodSec = dnsResolvePeriodSec;
  }

  public OutputHoneycomb loadBalanceStatsPeriodSec(BigDecimal loadBalanceStatsPeriodSec) {
    this.loadBalanceStatsPeriodSec = loadBalanceStatsPeriodSec;
    return this;
  }

   /**
   * How far back in time to keep traffic stats for load balancing purposes.
   * minimum: 10
   * @return loadBalanceStatsPeriodSec
  **/
  @Schema(description = "How far back in time to keep traffic stats for load balancing purposes.")
  public BigDecimal getLoadBalanceStatsPeriodSec() {
    return loadBalanceStatsPeriodSec;
  }

  public void setLoadBalanceStatsPeriodSec(BigDecimal loadBalanceStatsPeriodSec) {
    this.loadBalanceStatsPeriodSec = loadBalanceStatsPeriodSec;
  }

  public OutputHoneycomb maxConcurrentSenders(BigDecimal maxConcurrentSenders) {
    this.maxConcurrentSenders = maxConcurrentSenders;
    return this;
  }

   /**
   * Maximum number of concurrent connections (per worker process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited.
   * minimum: 0
   * @return maxConcurrentSenders
  **/
  @Schema(description = "Maximum number of concurrent connections (per worker process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited.")
  public BigDecimal getMaxConcurrentSenders() {
    return maxConcurrentSenders;
  }

  public void setMaxConcurrentSenders(BigDecimal maxConcurrentSenders) {
    this.maxConcurrentSenders = maxConcurrentSenders;
  }

  public OutputHoneycomb indexerDiscovery(Boolean indexerDiscovery) {
    this.indexerDiscovery = indexerDiscovery;
    return this;
  }

   /**
   * Automatically discover indexers in indexer clustering environment.
   * @return indexerDiscovery
  **/
  @Schema(description = "Automatically discover indexers in indexer clustering environment.")
  public Boolean isIndexerDiscovery() {
    return indexerDiscovery;
  }

  public void setIndexerDiscovery(Boolean indexerDiscovery) {
    this.indexerDiscovery = indexerDiscovery;
  }

  public OutputHoneycomb url(String url) {
    this.url = url;
    return this;
  }

   /**
   * The endpoint to send logs to.
   * @return url
  **/
  @Schema(required = true, description = "The endpoint to send logs to.")
  public String getUrl() {
    return url;
  }

  public void setUrl(String url) {
    this.url = url;
  }

  public OutputHoneycomb nextQueue(String nextQueue) {
    this.nextQueue = nextQueue;
    return this;
  }

   /**
   * Which Splunk processing queue to send the events after HEC processing
   * @return nextQueue
  **/
  @Schema(description = "Which Splunk processing queue to send the events after HEC processing")
  public String getNextQueue() {
    return nextQueue;
  }

  public void setNextQueue(String nextQueue) {
    this.nextQueue = nextQueue;
  }

  public OutputHoneycomb tcpRouting(String tcpRouting) {
    this.tcpRouting = tcpRouting;
    return this;
  }

   /**
   * Set the value of _TCP_ROUTING for events that does not have _ctrl._TCP_ROUTING set
   * @return tcpRouting
  **/
  @Schema(description = "Set the value of _TCP_ROUTING for events that does not have _ctrl._TCP_ROUTING set")
  public String getTcpRouting() {
    return tcpRouting;
  }

  public void setTcpRouting(String tcpRouting) {
    this.tcpRouting = tcpRouting;
  }

  public OutputHoneycomb concurrency(BigDecimal concurrency) {
    this.concurrency = concurrency;
    return this;
  }

   /**
   * Maximum number of ongoing requests before blocking. Warning: Setting this value &gt; 1 can cause Loki to complain about entries being delivered out of order.
   * minimum: 1
   * maximum: 32
   * @return concurrency
  **/
  @Schema(description = "Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki to complain about entries being delivered out of order.")
  public BigDecimal getConcurrency() {
    return concurrency;
  }

  public void setConcurrency(BigDecimal concurrency) {
    this.concurrency = concurrency;
  }

  public OutputHoneycomb maxPayloadSizeKB(BigDecimal maxPayloadSizeKB) {
    this.maxPayloadSizeKB = maxPayloadSizeKB;
    return this;
  }

   /**
   * Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of &#x27;Request concurrency&#x27;); this can cause Loki to complain about entries being delivered out of order.
   * minimum: 1024
   * maximum: 10240
   * @return maxPayloadSizeKB
  **/
  @Schema(description = "Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order.")
  public BigDecimal getMaxPayloadSizeKB() {
    return maxPayloadSizeKB;
  }

  public void setMaxPayloadSizeKB(BigDecimal maxPayloadSizeKB) {
    this.maxPayloadSizeKB = maxPayloadSizeKB;
  }

  public OutputHoneycomb maxPayloadEvents(BigDecimal maxPayloadEvents) {
    this.maxPayloadEvents = maxPayloadEvents;
    return this;
  }

   /**
   * Maximum number of events to include in the request body. Defaults to 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of &#x27;Request concurrency&#x27;); this can cause Loki to complain about entries being delivered out of order.
   * minimum: 0
   * @return maxPayloadEvents
  **/
  @Schema(description = "Maximum number of events to include in the request body. Defaults to 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order.")
  public BigDecimal getMaxPayloadEvents() {
    return maxPayloadEvents;
  }

  public void setMaxPayloadEvents(BigDecimal maxPayloadEvents) {
    this.maxPayloadEvents = maxPayloadEvents;
  }

  public OutputHoneycomb compress(Boolean compress) {
    this.compress = compress;
    return this;
  }

   /**
   * Whether to compress the payload body before sending.
   * @return compress
  **/
  @Schema(description = "Whether to compress the payload body before sending.")
  public Boolean isCompress() {
    return compress;
  }

  public void setCompress(Boolean compress) {
    this.compress = compress;
  }

  public OutputHoneycomb rejectUnauthorized(Boolean rejectUnauthorized) {
    this.rejectUnauthorized = rejectUnauthorized;
    return this;
  }

   /**
   * Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (e.g., the system&#x27;s CA). Defaults to No.
   * @return rejectUnauthorized
  **/
  @Schema(description = "Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (e.g., the system's CA). Defaults to No.")
  public Boolean isRejectUnauthorized() {
    return rejectUnauthorized;
  }

  public void setRejectUnauthorized(Boolean rejectUnauthorized) {
    this.rejectUnauthorized = rejectUnauthorized;
  }

  public OutputHoneycomb timeoutSec(BigDecimal timeoutSec) {
    this.timeoutSec = timeoutSec;
    return this;
  }

   /**
   * Amount of time, in seconds, to wait for a request to complete before aborting it.
   * minimum: 1
   * maximum: 9007199254740991
   * @return timeoutSec
  **/
  @Schema(description = "Amount of time, in seconds, to wait for a request to complete before aborting it.")
  public BigDecimal getTimeoutSec() {
    return timeoutSec;
  }

  public void setTimeoutSec(BigDecimal timeoutSec) {
    this.timeoutSec = timeoutSec;
  }

  public OutputHoneycomb flushPeriodSec(BigDecimal flushPeriodSec) {
    this.flushPeriodSec = flushPeriodSec;
    return this;
  }

   /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured &#x27;Max record size&#x27; and &#x27;Max events per request&#x27;. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of &#x27;Request concurrency&#x27;); this can cause Loki to complain about entries being delivered out of order.
   * @return flushPeriodSec
  **/
  @Schema(description = "Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order.")
  public BigDecimal getFlushPeriodSec() {
    return flushPeriodSec;
  }

  public void setFlushPeriodSec(BigDecimal flushPeriodSec) {
    this.flushPeriodSec = flushPeriodSec;
  }

  public OutputHoneycomb extraHttpHeaders(List<NotificationTargetWebhookExtraHttpHeaders> extraHttpHeaders) {
    this.extraHttpHeaders = extraHttpHeaders;
    return this;
  }

  public OutputHoneycomb addExtraHttpHeadersItem(NotificationTargetWebhookExtraHttpHeaders extraHttpHeadersItem) {
    if (this.extraHttpHeaders == null) {
      this.extraHttpHeaders = new ArrayList<>();
    }
    this.extraHttpHeaders.add(extraHttpHeadersItem);
    return this;
  }

   /**
   * Extra HTTP Headers.
   * @return extraHttpHeaders
  **/
  @Schema(description = "Extra HTTP Headers.")
  public List<NotificationTargetWebhookExtraHttpHeaders> getExtraHttpHeaders() {
    return extraHttpHeaders;
  }

  public void setExtraHttpHeaders(List<NotificationTargetWebhookExtraHttpHeaders> extraHttpHeaders) {
    this.extraHttpHeaders = extraHttpHeaders;
  }

  public OutputHoneycomb useRoundRobinDns(Boolean useRoundRobinDns) {
    this.useRoundRobinDns = useRoundRobinDns;
    return this;
  }

   /**
   * Enable to use round-robin DNS lookup. When a DNS server returns multiple addresses, this will cause LogStream to cycle through them in the order returned.
   * @return useRoundRobinDns
  **/
  @Schema(description = "Enable to use round-robin DNS lookup. When a DNS server returns multiple addresses, this will cause LogStream to cycle through them in the order returned.")
  public Boolean isUseRoundRobinDns() {
    return useRoundRobinDns;
  }

  public void setUseRoundRobinDns(Boolean useRoundRobinDns) {
    this.useRoundRobinDns = useRoundRobinDns;
  }

  public OutputHoneycomb domain(String domain) {
    this.domain = domain;
    return this;
  }

   /**
   * WaveFront domain name, e.g. \&quot;longboard\&quot;
   * @return domain
  **/
  @Schema(description = "WaveFront domain name, e.g. \"longboard\"")
  public String getDomain() {
    return domain;
  }

  public void setDomain(String domain) {
    this.domain = domain;
  }

  public OutputHoneycomb realm(String realm) {
    this.realm = realm;
    return this;
  }

   /**
   * SignalFx realm name, e.g. \&quot;us0\&quot;
   * @return realm
  **/
  @Schema(description = "SignalFx realm name, e.g. \"us0\"")
  public String getRealm() {
    return realm;
  }

  public void setRealm(String realm) {
    this.realm = realm;
  }

  public OutputHoneycomb destPath(String destPath) {
    this.destPath = destPath;
    return this;
  }

   /**
   * Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: &#x60;myKeyPrefix-${C.vars.myVar}&#x60;.
   * @return destPath
  **/
  @Schema(required = true, description = "Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`.")
  public String getDestPath() {
    return destPath;
  }

  public void setDestPath(String destPath) {
    this.destPath = destPath;
  }

  public OutputHoneycomb stagePath(String stagePath) {
    this.stagePath = stagePath;
    return this;
  }

   /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage.
   * @return stagePath
  **/
  @Schema(required = true, description = "Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage.")
  public String getStagePath() {
    return stagePath;
  }

  public void setStagePath(String stagePath) {
    this.stagePath = stagePath;
  }

  public OutputHoneycomb addIdToStagePath(Boolean addIdToStagePath) {
    this.addIdToStagePath = addIdToStagePath;
    return this;
  }

   /**
   * Append output&#x27;s ID to staging location.
   * @return addIdToStagePath
  **/
  @Schema(description = "Append output's ID to staging location.")
  public Boolean isAddIdToStagePath() {
    return addIdToStagePath;
  }

  public void setAddIdToStagePath(Boolean addIdToStagePath) {
    this.addIdToStagePath = addIdToStagePath;
  }

  public OutputHoneycomb removeEmptyDirs(Boolean removeEmptyDirs) {
    this.removeEmptyDirs = removeEmptyDirs;
    return this;
  }

   /**
   * Remove empty staging directories after moving files.
   * @return removeEmptyDirs
  **/
  @Schema(description = "Remove empty staging directories after moving files.")
  public Boolean isRemoveEmptyDirs() {
    return removeEmptyDirs;
  }

  public void setRemoveEmptyDirs(Boolean removeEmptyDirs) {
    this.removeEmptyDirs = removeEmptyDirs;
  }

  public OutputHoneycomb partitionExpr(String partitionExpr) {
    this.partitionExpr = partitionExpr;
    return this;
  }

   /**
   * JS expression to define how files are partitioned and organized. If left blank, Cribl LogStream will fallback on event.__partition.
   * @return partitionExpr
  **/
  @Schema(description = "JS expression to define how files are partitioned and organized. If left blank, Cribl LogStream will fallback on event.__partition.")
  public String getPartitionExpr() {
    return partitionExpr;
  }

  public void setPartitionExpr(String partitionExpr) {
    this.partitionExpr = partitionExpr;
  }

  public OutputHoneycomb format(FormatEnum format) {
    this.format = format;
    return this;
  }

   /**
   * Specifies how to format events before sending out. Defaults to NDJSON.
   * @return format
  **/
  @Schema(description = "Specifies how to format events before sending out. Defaults to NDJSON.")
  public FormatEnum getFormat() {
    return format;
  }

  public void setFormat(FormatEnum format) {
    this.format = format;
  }

  public OutputHoneycomb baseFileName(String baseFileName) {
    this.baseFileName = baseFileName;
    return this;
  }

   /**
   * JavaScript expression to define the output filename prefix (can be constant).
   * @return baseFileName
  **/
  @Schema(description = "JavaScript expression to define the output filename prefix (can be constant).")
  public String getBaseFileName() {
    return baseFileName;
  }

  public void setBaseFileName(String baseFileName) {
    this.baseFileName = baseFileName;
  }

  public OutputHoneycomb maxFileSizeMB(BigDecimal maxFileSizeMB) {
    this.maxFileSizeMB = maxFileSizeMB;
    return this;
  }

   /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   * minimum: 5
   * maximum: 1024
   * @return maxFileSizeMB
  **/
  @Schema(description = "Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.")
  public BigDecimal getMaxFileSizeMB() {
    return maxFileSizeMB;
  }

  public void setMaxFileSizeMB(BigDecimal maxFileSizeMB) {
    this.maxFileSizeMB = maxFileSizeMB;
  }

  public OutputHoneycomb maxFileOpenTimeSec(BigDecimal maxFileOpenTimeSec) {
    this.maxFileOpenTimeSec = maxFileOpenTimeSec;
    return this;
  }

   /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   * minimum: 10
   * maximum: 1800
   * @return maxFileOpenTimeSec
  **/
  @Schema(description = "Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.")
  public BigDecimal getMaxFileOpenTimeSec() {
    return maxFileOpenTimeSec;
  }

  public void setMaxFileOpenTimeSec(BigDecimal maxFileOpenTimeSec) {
    this.maxFileOpenTimeSec = maxFileOpenTimeSec;
  }

  public OutputHoneycomb maxFileIdleTimeSec(BigDecimal maxFileIdleTimeSec) {
    this.maxFileIdleTimeSec = maxFileIdleTimeSec;
    return this;
  }

   /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   * minimum: 5
   * maximum: 1800
   * @return maxFileIdleTimeSec
  **/
  @Schema(description = "Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.")
  public BigDecimal getMaxFileIdleTimeSec() {
    return maxFileIdleTimeSec;
  }

  public void setMaxFileIdleTimeSec(BigDecimal maxFileIdleTimeSec) {
    this.maxFileIdleTimeSec = maxFileIdleTimeSec;
  }

  public OutputHoneycomb maxOpenFiles(BigDecimal maxOpenFiles) {
    this.maxOpenFiles = maxOpenFiles;
    return this;
  }

   /**
   * Maximum number of files to keep open concurrently. When over, the oldest open files will be closed and moved to final output location.
   * minimum: 10
   * maximum: 2000
   * @return maxOpenFiles
  **/
  @Schema(description = "Maximum number of files to keep open concurrently. When over, the oldest open files will be closed and moved to final output location.")
  public BigDecimal getMaxOpenFiles() {
    return maxOpenFiles;
  }

  public void setMaxOpenFiles(BigDecimal maxOpenFiles) {
    this.maxOpenFiles = maxOpenFiles;
  }

  public OutputHoneycomb bucket(String bucket) {
    this.bucket = bucket;
    return this;
  }

   /**
   * Name of the destination Bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. E.g. referencing a Global Variable: &#x60;myBucket-${C.vars.myVar}&#x60;.
   * @return bucket
  **/
  @Schema(description = "Name of the destination Bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. E.g. referencing a Global Variable: `myBucket-${C.vars.myVar}`.")
  public String getBucket() {
    return bucket;
  }

  public void setBucket(String bucket) {
    this.bucket = bucket;
  }

  public OutputHoneycomb region(RegionEnum region) {
    this.region = region;
    return this;
  }

   /**
   * Region to publish messages to. Select &#x27;default&#x27; to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
   * @return region
  **/
  @Schema(required = true, description = "Region to publish messages to. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.")
  public RegionEnum getRegion() {
    return region;
  }

  public void setRegion(RegionEnum region) {
    this.region = region;
  }

  public OutputHoneycomb awsAuthenticationMethod(AwsAuthenticationMethodEnum awsAuthenticationMethod) {
    this.awsAuthenticationMethod = awsAuthenticationMethod;
    return this;
  }

   /**
   * AWS authentication method. Choose Auto to use IAM roles.
   * @return awsAuthenticationMethod
  **/
  @Schema(description = "AWS authentication method. Choose Auto to use IAM roles.")
  public AwsAuthenticationMethodEnum getAwsAuthenticationMethod() {
    return awsAuthenticationMethod;
  }

  public void setAwsAuthenticationMethod(AwsAuthenticationMethodEnum awsAuthenticationMethod) {
    this.awsAuthenticationMethod = awsAuthenticationMethod;
  }

  public OutputHoneycomb awsSecretKey(String awsSecretKey) {
    this.awsSecretKey = awsSecretKey;
    return this;
  }

   /**
   * Secret key
   * @return awsSecretKey
  **/
  @Schema(description = "Secret key")
  public String getAwsSecretKey() {
    return awsSecretKey;
  }

  public void setAwsSecretKey(String awsSecretKey) {
    this.awsSecretKey = awsSecretKey;
  }

  public OutputHoneycomb endpoint(String endpoint) {
    this.endpoint = endpoint;
    return this;
  }

   /**
   * Google Cloud Storage service endpoint.
   * @return endpoint
  **/
  @Schema(required = true, description = "Google Cloud Storage service endpoint.")
  public String getEndpoint() {
    return endpoint;
  }

  public void setEndpoint(String endpoint) {
    this.endpoint = endpoint;
  }

  public OutputHoneycomb signatureVersion(SignatureVersionEnum signatureVersion) {
    this.signatureVersion = signatureVersion;
    return this;
  }

   /**
   * Signature version to use for signing Google Cloud Storage requests.
   * @return signatureVersion
  **/
  @Schema(description = "Signature version to use for signing Google Cloud Storage requests.")
  public SignatureVersionEnum getSignatureVersion() {
    return signatureVersion;
  }

  public void setSignatureVersion(SignatureVersionEnum signatureVersion) {
    this.signatureVersion = signatureVersion;
  }

  public OutputHoneycomb reuseConnections(Boolean reuseConnections) {
    this.reuseConnections = reuseConnections;
    return this;
  }

   /**
   * Whether to reuse connections between requests, which can improve performance.
   * @return reuseConnections
  **/
  @Schema(description = "Whether to reuse connections between requests, which can improve performance.")
  public Boolean isReuseConnections() {
    return reuseConnections;
  }

  public void setReuseConnections(Boolean reuseConnections) {
    this.reuseConnections = reuseConnections;
  }

  public OutputHoneycomb enableAssumeRole(Boolean enableAssumeRole) {
    this.enableAssumeRole = enableAssumeRole;
    return this;
  }

   /**
   * Use Assume Role credentials to access SQS
   * @return enableAssumeRole
  **/
  @Schema(description = "Use Assume Role credentials to access SQS")
  public Boolean isEnableAssumeRole() {
    return enableAssumeRole;
  }

  public void setEnableAssumeRole(Boolean enableAssumeRole) {
    this.enableAssumeRole = enableAssumeRole;
  }

  public OutputHoneycomb assumeRoleArn(String assumeRoleArn) {
    this.assumeRoleArn = assumeRoleArn;
    return this;
  }

   /**
   * Amazon Resource Name (ARN) of the role to assume
   * @return assumeRoleArn
  **/
  @Schema(description = "Amazon Resource Name (ARN) of the role to assume")
  public String getAssumeRoleArn() {
    return assumeRoleArn;
  }

  public void setAssumeRoleArn(String assumeRoleArn) {
    this.assumeRoleArn = assumeRoleArn;
  }

  public OutputHoneycomb assumeRoleExternalId(String assumeRoleExternalId) {
    this.assumeRoleExternalId = assumeRoleExternalId;
    return this;
  }

   /**
   * External ID to use when assuming role
   * @return assumeRoleExternalId
  **/
  @Schema(description = "External ID to use when assuming role")
  public String getAssumeRoleExternalId() {
    return assumeRoleExternalId;
  }

  public void setAssumeRoleExternalId(String assumeRoleExternalId) {
    this.assumeRoleExternalId = assumeRoleExternalId;
  }

  public OutputHoneycomb objectACL(ObjectACLEnum objectACL) {
    this.objectACL = objectACL;
    return this;
  }

   /**
   * Object ACL to assign to uploaded objects.
   * @return objectACL
  **/
  @Schema(description = "Object ACL to assign to uploaded objects.")
  public ObjectACLEnum getObjectACL() {
    return objectACL;
  }

  public void setObjectACL(ObjectACLEnum objectACL) {
    this.objectACL = objectACL;
  }

  public OutputHoneycomb storageClass(StorageClassEnum storageClass) {
    this.storageClass = storageClass;
    return this;
  }

   /**
   * Storage class to select for uploaded objects.
   * @return storageClass
  **/
  @Schema(description = "Storage class to select for uploaded objects.")
  public StorageClassEnum getStorageClass() {
    return storageClass;
  }

  public void setStorageClass(StorageClassEnum storageClass) {
    this.storageClass = storageClass;
  }

  public OutputHoneycomb serverSideEncryption(ServerSideEncryptionEnum serverSideEncryption) {
    this.serverSideEncryption = serverSideEncryption;
    return this;
  }

   /**
   * Server-side encryption for uploaded objects.
   * @return serverSideEncryption
  **/
  @Schema(description = "Server-side encryption for uploaded objects.")
  public ServerSideEncryptionEnum getServerSideEncryption() {
    return serverSideEncryption;
  }

  public void setServerSideEncryption(ServerSideEncryptionEnum serverSideEncryption) {
    this.serverSideEncryption = serverSideEncryption;
  }

  public OutputHoneycomb kmsKeyId(Object kmsKeyId) {
    this.kmsKeyId = kmsKeyId;
    return this;
  }

   /**
   * Get kmsKeyId
   * @return kmsKeyId
  **/
  @Schema(description = "")
  public Object getKmsKeyId() {
    return kmsKeyId;
  }

  public void setKmsKeyId(Object kmsKeyId) {
    this.kmsKeyId = kmsKeyId;
  }

  public OutputHoneycomb containerName(String containerName) {
    this.containerName = containerName;
    return this;
  }

   /**
   * A container organizes a set of blobs, similar to a directory in a file system.
   * @return containerName
  **/
  @Schema(description = "A container organizes a set of blobs, similar to a directory in a file system.")
  public String getContainerName() {
    return containerName;
  }

  public void setContainerName(String containerName) {
    this.containerName = containerName;
  }

  public OutputHoneycomb createContainer(Boolean createContainer) {
    this.createContainer = createContainer;
    return this;
  }

   /**
   * Creates the configured container in Azure Blob Storage if it does not already exist.
   * @return createContainer
  **/
  @Schema(description = "Creates the configured container in Azure Blob Storage if it does not already exist.")
  public Boolean isCreateContainer() {
    return createContainer;
  }

  public void setCreateContainer(Boolean createContainer) {
    this.createContainer = createContainer;
  }

  public OutputHoneycomb logType(LogTypeEnum logType) {
    this.logType = logType;
    return this;
  }

   /**
   * Log type value to send to Chronicle. Can be overwritten by event field __logType.
   * @return logType
  **/
  @Schema(description = "Log type value to send to Chronicle. Can be overwritten by event field __logType.")
  public LogTypeEnum getLogType() {
    return logType;
  }

  public void setLogType(LogTypeEnum logType) {
    this.logType = logType;
  }

  public OutputHoneycomb resourceId(String resourceId) {
    this.resourceId = resourceId;
    return this;
  }

   /**
   * Optional Resource ID of the Azure resource the data should be associated with, can be overridden by event field __resourceId. This populates the _ResourceId property and allows the data to be included in resource-centric queries. If this field isn&#x27;t specified, the data will not be included in resource-centric queries.
   * @return resourceId
  **/
  @Schema(description = "Optional Resource ID of the Azure resource the data should be associated with, can be overridden by event field __resourceId. This populates the _ResourceId property and allows the data to be included in resource-centric queries. If this field isn't specified, the data will not be included in resource-centric queries.")
  public String getResourceId() {
    return resourceId;
  }

  public void setResourceId(String resourceId) {
    this.resourceId = resourceId;
  }

  public OutputHoneycomb streamName(String streamName) {
    this.streamName = streamName;
    return this;
  }

   /**
   * Kinesis stream name where to send events.
   * @return streamName
  **/
  @Schema(description = "Kinesis stream name where to send events.")
  public String getStreamName() {
    return streamName;
  }

  public void setStreamName(String streamName) {
    this.streamName = streamName;
  }

  public OutputHoneycomb maxRecordSizeKB(BigDecimal maxRecordSizeKB) {
    this.maxRecordSizeKB = maxRecordSizeKB;
    return this;
  }

   /**
   * Maximum size (KB) of batches to send.
   * minimum: 1
   * maximum: 256
   * @return maxRecordSizeKB
  **/
  @Schema(description = "Maximum size (KB) of batches to send.")
  public BigDecimal getMaxRecordSizeKB() {
    return maxRecordSizeKB;
  }

  public void setMaxRecordSizeKB(BigDecimal maxRecordSizeKB) {
    this.maxRecordSizeKB = maxRecordSizeKB;
  }

  public OutputHoneycomb dataset(String dataset) {
    this.dataset = dataset;
    return this;
  }

   /**
   * Name of the dataset to send events to – e.g., observability
   * @return dataset
  **/
  @Schema(description = "Name of the dataset to send events to – e.g., observability")
  public String getDataset() {
    return dataset;
  }

  public void setDataset(String dataset) {
    this.dataset = dataset;
  }

  public OutputHoneycomb messageField(String messageField) {
    this.messageField = messageField;
    return this;
  }

   /**
   * Name of field to send as log message value. If not present, event will be serialized and sent as JSON.
   * @return messageField
  **/
  @Schema(description = "Name of field to send as log message value. If not present, event will be serialized and sent as JSON.")
  public String getMessageField() {
    return messageField;
  }

  public void setMessageField(String messageField) {
    this.messageField = messageField;
  }

  public OutputHoneycomb metadata(List<OutputDefaultMetadata> metadata) {
    this.metadata = metadata;
    return this;
  }

  public OutputHoneycomb addMetadataItem(OutputDefaultMetadata metadataItem) {
    if (this.metadata == null) {
      this.metadata = new ArrayList<>();
    }
    this.metadata.add(metadataItem);
    return this;
  }

   /**
   * Fields to add.
   * @return metadata
  **/
  @Schema(description = "Fields to add.")
  public List<OutputDefaultMetadata> getMetadata() {
    return metadata;
  }

  public void setMetadata(List<OutputDefaultMetadata> metadata) {
    this.metadata = metadata;
  }

  public OutputHoneycomb accountId(String accountId) {
    this.accountId = accountId;
    return this;
  }

   /**
   * New Relic account ID
   * @return accountId
  **/
  @Schema(description = "New Relic account ID")
  public String getAccountId() {
    return accountId;
  }

  public void setAccountId(String accountId) {
    this.accountId = accountId;
  }

  public OutputHoneycomb eventType(String eventType) {
    this.eventType = eventType;
    return this;
  }

   /**
   * Default eventType to use when not present in an event. For more information, see [here](https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/#reserved-words).
   * @return eventType
  **/
  @Schema(description = "Default eventType to use when not present in an event. For more information, see [here](https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/#reserved-words).")
  public String getEventType() {
    return eventType;
  }

  public void setEventType(String eventType) {
    this.eventType = eventType;
  }

  public OutputHoneycomb index(String index) {
    this.index = index;
    return this;
  }

   /**
   * Index where to send events. Can be overwritten by an event&#x27;s __index field
   * @return index
  **/
  @Schema(description = "Index where to send events. Can be overwritten by an event's __index field")
  public String getIndex() {
    return index;
  }

  public void setIndex(String index) {
    this.index = index;
  }

  public OutputHoneycomb docType(String docType) {
    this.docType = docType;
    return this;
  }

   /**
   * Document type to use for events. Can be overwritten by an event&#x27;s __type field
   * @return docType
  **/
  @Schema(description = "Document type to use for events. Can be overwritten by an event's __type field")
  public String getDocType() {
    return docType;
  }

  public void setDocType(String docType) {
    this.docType = docType;
  }

  public OutputHoneycomb auth(OutputDefaultAuth auth) {
    this.auth = auth;
    return this;
  }

   /**
   * Get auth
   * @return auth
  **/
  @Schema(description = "")
  public OutputDefaultAuth getAuth() {
    return auth;
  }

  public void setAuth(OutputDefaultAuth auth) {
    this.auth = auth;
  }

  public OutputHoneycomb elasticVersion(ElasticVersionEnum elasticVersion) {
    this.elasticVersion = elasticVersion;
    return this;
  }

   /**
   * Optional Elasticsearch version, used to format events. If not specified, will auto-discover version.
   * @return elasticVersion
  **/
  @Schema(description = "Optional Elasticsearch version, used to format events. If not specified, will auto-discover version.")
  public ElasticVersionEnum getElasticVersion() {
    return elasticVersion;
  }

  public void setElasticVersion(ElasticVersionEnum elasticVersion) {
    this.elasticVersion = elasticVersion;
  }

  public OutputHoneycomb brokers(List<String> brokers) {
    this.brokers = brokers;
    return this;
  }

  public OutputHoneycomb addBrokersItem(String brokersItem) {
    if (this.brokers == null) {
      this.brokers = new ArrayList<>();
    }
    this.brokers.add(brokersItem);
    return this;
  }

   /**
   * List of Event Hubs Kafka brokers to connect to, eg. yourdomain.servicebus.windows.net:9093. The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
   * @return brokers
  **/
  @Schema(description = "List of Event Hubs Kafka brokers to connect to, eg. yourdomain.servicebus.windows.net:9093. The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.")
  public List<String> getBrokers() {
    return brokers;
  }

  public void setBrokers(List<String> brokers) {
    this.brokers = brokers;
  }

  public OutputHoneycomb topic(String topic) {
    this.topic = topic;
    return this;
  }

   /**
   * The name of the Event Hub (a.k.a. Kafka Topic) to publish events. Can be overwritten using field __topicOut.
   * @return topic
  **/
  @Schema(description = "The name of the Event Hub (a.k.a. Kafka Topic) to publish events. Can be overwritten using field __topicOut.")
  public String getTopic() {
    return topic;
  }

  public void setTopic(String topic) {
    this.topic = topic;
  }

  public OutputHoneycomb ack(AckEnum ack) {
    this.ack = ack;
    return this;
  }

   /**
   * Control the number of required acknowledgments
   * @return ack
  **/
  @Schema(description = "Control the number of required acknowledgments")
  public AckEnum getAck() {
    return ack;
  }

  public void setAck(AckEnum ack) {
    this.ack = ack;
  }

  public OutputHoneycomb flushEventCount(BigDecimal flushEventCount) {
    this.flushEventCount = flushEventCount;
    return this;
  }

   /**
   * Maximum number of events in a batch before forcing a flush.
   * minimum: 1
   * maximum: 10000
   * @return flushEventCount
  **/
  @Schema(description = "Maximum number of events in a batch before forcing a flush.")
  public BigDecimal getFlushEventCount() {
    return flushEventCount;
  }

  public void setFlushEventCount(BigDecimal flushEventCount) {
    this.flushEventCount = flushEventCount;
  }

  public OutputHoneycomb kafkaSchemaRegistry(KafkaSchemaRegistryAuthentication kafkaSchemaRegistry) {
    this.kafkaSchemaRegistry = kafkaSchemaRegistry;
    return this;
  }

   /**
   * Get kafkaSchemaRegistry
   * @return kafkaSchemaRegistry
  **/
  @Schema(description = "")
  public KafkaSchemaRegistryAuthentication getKafkaSchemaRegistry() {
    return kafkaSchemaRegistry;
  }

  public void setKafkaSchemaRegistry(KafkaSchemaRegistryAuthentication kafkaSchemaRegistry) {
    this.kafkaSchemaRegistry = kafkaSchemaRegistry;
  }

  public OutputHoneycomb sasl(Authentication sasl) {
    this.sasl = sasl;
    return this;
  }

   /**
   * Get sasl
   * @return sasl
  **/
  @Schema(description = "")
  public Authentication getSasl() {
    return sasl;
  }

  public void setSasl(Authentication sasl) {
    this.sasl = sasl;
  }

  public OutputHoneycomb database(String database) {
    this.database = database;
    return this;
  }

   /**
   * The database where to write data points.
   * @return database
  **/
  @Schema(description = "The database where to write data points.")
  public String getDatabase() {
    return database;
  }

  public void setDatabase(String database) {
    this.database = database;
  }

  public OutputHoneycomb timestampPrecision(TimestampPrecisionEnum timestampPrecision) {
    this.timestampPrecision = timestampPrecision;
    return this;
  }

   /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   * @return timestampPrecision
  **/
  @Schema(description = "Sets the precision for the supplied Unix time values. Defaults to milliseconds.")
  public TimestampPrecisionEnum getTimestampPrecision() {
    return timestampPrecision;
  }

  public void setTimestampPrecision(TimestampPrecisionEnum timestampPrecision) {
    this.timestampPrecision = timestampPrecision;
  }

  public OutputHoneycomb dynamicValueFieldName(Boolean dynamicValueFieldName) {
    this.dynamicValueFieldName = dynamicValueFieldName;
    return this;
  }

   /**
   * Enabling this will pull the value field from the metric name (ex. db.query.user will use db.query as the measurement and user as the value field).
   * @return dynamicValueFieldName
  **/
  @Schema(description = "Enabling this will pull the value field from the metric name (ex. db.query.user will use db.query as the measurement and user as the value field).")
  public Boolean isDynamicValueFieldName() {
    return dynamicValueFieldName;
  }

  public void setDynamicValueFieldName(Boolean dynamicValueFieldName) {
    this.dynamicValueFieldName = dynamicValueFieldName;
  }

  public OutputHoneycomb valueFieldName(String valueFieldName) {
    this.valueFieldName = valueFieldName;
    return this;
  }

   /**
   * The name of the field to store the metric in when sending to InfluxDb. Will be used as a fallback if dynamic generation is enabled and fails.
   * @return valueFieldName
  **/
  @Schema(description = "The name of the field to store the metric in when sending to InfluxDb. Will be used as a fallback if dynamic generation is enabled and fails.")
  public String getValueFieldName() {
    return valueFieldName;
  }

  public void setValueFieldName(String valueFieldName) {
    this.valueFieldName = valueFieldName;
  }

  public OutputHoneycomb logGroupName(String logGroupName) {
    this.logGroupName = logGroupName;
    return this;
  }

   /**
   * CloudWatch log group to associate events with
   * @return logGroupName
  **/
  @Schema(description = "CloudWatch log group to associate events with")
  public String getLogGroupName() {
    return logGroupName;
  }

  public void setLogGroupName(String logGroupName) {
    this.logGroupName = logGroupName;
  }

  public OutputHoneycomb logStreamName(String logStreamName) {
    this.logStreamName = logStreamName;
    return this;
  }

   /**
   * Prefix for CloudWatch log stream name. This prefix will be used to generate a unique log stream name per cribl instance, for example: myStream_myHost_myOutputId
   * @return logStreamName
  **/
  @Schema(description = "Prefix for CloudWatch log stream name. This prefix will be used to generate a unique log stream name per cribl instance, for example: myStream_myHost_myOutputId")
  public String getLogStreamName() {
    return logStreamName;
  }

  public void setLogStreamName(String logStreamName) {
    this.logStreamName = logStreamName;
  }

  public OutputHoneycomb maxQueueSize(BigDecimal maxQueueSize) {
    this.maxQueueSize = maxQueueSize;
    return this;
  }

   /**
   * Maximum number of queued batches before blocking.
   * minimum: 1
   * maximum: 32
   * @return maxQueueSize
  **/
  @Schema(description = "Maximum number of queued batches before blocking.")
  public BigDecimal getMaxQueueSize() {
    return maxQueueSize;
  }

  public void setMaxQueueSize(BigDecimal maxQueueSize) {
    this.maxQueueSize = maxQueueSize;
  }

  public OutputHoneycomb mtu(BigDecimal mtu) {
    this.mtu = mtu;
    return this;
  }

   /**
   * Used when Protocol is UDP, to specify the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system.
   * minimum: 1
   * @return mtu
  **/
  @Schema(description = "Used when Protocol is UDP, to specify the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system.")
  public BigDecimal getMtu() {
    return mtu;
  }

  public void setMtu(BigDecimal mtu) {
    this.mtu = mtu;
  }

  public OutputHoneycomb rules(List<NotificationTargetRouterRules> rules) {
    this.rules = rules;
    return this;
  }

  public OutputHoneycomb addRulesItem(NotificationTargetRouterRules rulesItem) {
    if (this.rules == null) {
      this.rules = new ArrayList<>();
    }
    this.rules.add(rulesItem);
    return this;
  }

   /**
   * Event routing rules
   * @return rules
  **/
  @Schema(description = "Event routing rules")
  public List<NotificationTargetRouterRules> getRules() {
    return rules;
  }

  public void setRules(List<NotificationTargetRouterRules> rules) {
    this.rules = rules;
  }

  public OutputHoneycomb queueName(String queueName) {
    this.queueName = queueName;
    return this;
  }

   /**
   * The name, URL, or ARN of the SQS queue to send events to. When a non-AWS URL is specified, format must be: &#x27;{url}/myQueueName&#x27;. E.g., &#x27;https://host:port/myQueueName&#x27;. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: &#x60;https://host:port/myQueue-${C.vars.myVar}&#x60;.
   * @return queueName
  **/
  @Schema(description = "The name, URL, or ARN of the SQS queue to send events to. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.")
  public String getQueueName() {
    return queueName;
  }

  public void setQueueName(String queueName) {
    this.queueName = queueName;
  }

  public OutputHoneycomb queueType(QueueTypeEnum queueType) {
    this.queueType = queueType;
    return this;
  }

   /**
   * The queue type used (or created). Defaults to Standard.
   * @return queueType
  **/
  @Schema(description = "The queue type used (or created). Defaults to Standard.")
  public QueueTypeEnum getQueueType() {
    return queueType;
  }

  public void setQueueType(QueueTypeEnum queueType) {
    this.queueType = queueType;
  }

  public OutputHoneycomb awsAccountId(String awsAccountId) {
    this.awsAccountId = awsAccountId;
    return this;
  }

   /**
   * SQS queue owner&#x27;s AWS account ID. Leave empty if SQS queue is in same AWS account.
   * @return awsAccountId
  **/
  @Schema(description = "SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.")
  public String getAwsAccountId() {
    return awsAccountId;
  }

  public void setAwsAccountId(String awsAccountId) {
    this.awsAccountId = awsAccountId;
  }

  public OutputHoneycomb messageGroupId(String messageGroupId) {
    this.messageGroupId = messageGroupId;
    return this;
  }

   /**
   * This parameter applies only to FIFO queues. The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner. Use event field __messageGroupId to override this value.
   * @return messageGroupId
  **/
  @Schema(description = "This parameter applies only to FIFO queues. The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner. Use event field __messageGroupId to override this value.")
  public String getMessageGroupId() {
    return messageGroupId;
  }

  public void setMessageGroupId(String messageGroupId) {
    this.messageGroupId = messageGroupId;
  }

  public OutputHoneycomb createQueue(Boolean createQueue) {
    this.createQueue = createQueue;
    return this;
  }

   /**
   * Create queue if it does not exist.
   * @return createQueue
  **/
  @Schema(description = "Create queue if it does not exist.")
  public Boolean isCreateQueue() {
    return createQueue;
  }

  public void setCreateQueue(Boolean createQueue) {
    this.createQueue = createQueue;
  }

  public OutputHoneycomb maxInProgress(BigDecimal maxInProgress) {
    this.maxInProgress = maxInProgress;
    return this;
  }

   /**
   * The maximum number of in-progress API requests before backpressure is applied.
   * minimum: 1
   * maximum: 100
   * @return maxInProgress
  **/
  @Schema(description = "The maximum number of in-progress API requests before backpressure is applied.")
  public BigDecimal getMaxInProgress() {
    return maxInProgress;
  }

  public void setMaxInProgress(BigDecimal maxInProgress) {
    this.maxInProgress = maxInProgress;
  }

  public OutputHoneycomb hosts(List<OutputDefaultHosts> hosts) {
    this.hosts = hosts;
    return this;
  }

  public OutputHoneycomb addHostsItem(OutputDefaultHosts hostsItem) {
    if (this.hosts == null) {
      this.hosts = new ArrayList<>();
    }
    this.hosts.add(hostsItem);
    return this;
  }

   /**
   * One or more SNMP destinations to forward traps to
   * @return hosts
  **/
  @Schema(description = "One or more SNMP destinations to forward traps to")
  public List<OutputDefaultHosts> getHosts() {
    return hosts;
  }

  public void setHosts(List<OutputDefaultHosts> hosts) {
    this.hosts = hosts;
  }

  public OutputHoneycomb customSource(String customSource) {
    this.customSource = customSource;
    return this;
  }

   /**
   * Optionally, override the source name configured on the Sumo Logic HTTP collector.
   * @return customSource
  **/
  @Schema(description = "Optionally, override the source name configured on the Sumo Logic HTTP collector.")
  public String getCustomSource() {
    return customSource;
  }

  public void setCustomSource(String customSource) {
    this.customSource = customSource;
  }

  public OutputHoneycomb customCategory(String customCategory) {
    this.customCategory = customCategory;
    return this;
  }

   /**
   * Optionally, override the source category configured on the Sumo Logic HTTP collector.
   * @return customCategory
  **/
  @Schema(description = "Optionally, override the source category configured on the Sumo Logic HTTP collector.")
  public String getCustomCategory() {
    return customCategory;
  }

  public void setCustomCategory(String customCategory) {
    this.customCategory = customCategory;
  }

  public OutputHoneycomb contentType(ContentTypeEnum contentType) {
    this.contentType = contentType;
    return this;
  }

   /**
   * The content type to use when sending logs.
   * @return contentType
  **/
  @Schema(description = "The content type to use when sending logs.")
  public ContentTypeEnum getContentType() {
    return contentType;
  }

  public void setContentType(ContentTypeEnum contentType) {
    this.contentType = contentType;
  }

  public OutputHoneycomb message(String message) {
    this.message = message;
    return this;
  }

   /**
   * Name of the event field that contains the message to send. If not specified, LogStream sends a JSON representation of the whole event.
   * @return message
  **/
  @Schema(description = "Name of the event field that contains the message to send. If not specified, LogStream sends a JSON representation of the whole event.")
  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }

  public OutputHoneycomb source(String source) {
    this.source = source;
    return this;
  }

   /**
   * Name of the source to send with logs. When you send logs as JSON objects, the event&#x27;s &#x27;source&#x27; field (if set) will override this value.
   * @return source
  **/
  @Schema(description = "Name of the source to send with logs. When you send logs as JSON objects, the event's 'source' field (if set) will override this value.")
  public String getSource() {
    return source;
  }

  public void setSource(String source) {
    this.source = source;
  }

  public OutputHoneycomb service(String service) {
    this.service = service;
    return this;
  }

   /**
   * Name of the service to send with logs. When you send logs as JSON objects, the event&#x27;s &#x27;__service&#x27; field (if set) will override this value.
   * @return service
  **/
  @Schema(description = "Name of the service to send with logs. When you send logs as JSON objects, the event's '__service' field (if set) will override this value.")
  public String getService() {
    return service;
  }

  public void setService(String service) {
    this.service = service;
  }

  public OutputHoneycomb tags(List<String> tags) {
    this.tags = tags;
    return this;
  }

  public OutputHoneycomb addTagsItem(String tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<>();
    }
    this.tags.add(tagsItem);
    return this;
  }

   /**
   * List of tags to send with logs (e.g., &#x27;env:prod&#x27;, &#x27;env_staging:east&#x27;).
   * @return tags
  **/
  @Schema(description = "List of tags to send with logs (e.g., 'env:prod', 'env_staging:east').")
  public List<String> getTags() {
    return tags;
  }

  public void setTags(List<String> tags) {
    this.tags = tags;
  }

  public OutputHoneycomb metricRenameExpr(String metricRenameExpr) {
    this.metricRenameExpr = metricRenameExpr;
    return this;
  }

   /**
   * A JS expression that can be used to rename metrics. E.g.: name.replace(/\\./g, &#x27;_&#x27;) will replace all &#x27;.&#x27; characters in a metric&#x27;s name with the supported &#x27;_&#x27; character. Use the &#x27;name&#x27; global variable to access the metric&#x27;s name.  You can access event fields&#x27; values via __e.&lt;fieldName&gt;.
   * @return metricRenameExpr
  **/
  @Schema(description = "A JS expression that can be used to rename metrics. E.g.: name.replace(/\\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name.  You can access event fields' values via __e.<fieldName>.")
  public String getMetricRenameExpr() {
    return metricRenameExpr;
  }

  public void setMetricRenameExpr(String metricRenameExpr) {
    this.metricRenameExpr = metricRenameExpr;
  }

  public OutputHoneycomb sendMetadata(Boolean sendMetadata) {
    this.sendMetadata = sendMetadata;
    return this;
  }

   /**
   * Whether to generate and send metadata (&#x60;type&#x60; and &#x60;metricFamilyName&#x60;) requests.
   * @return sendMetadata
  **/
  @Schema(description = "Whether to generate and send metadata (`type` and `metricFamilyName`) requests.")
  public Boolean isSendMetadata() {
    return sendMetadata;
  }

  public void setSendMetadata(Boolean sendMetadata) {
    this.sendMetadata = sendMetadata;
  }

  public OutputHoneycomb method(MethodEnum method) {
    this.method = method;
    return this;
  }

   /**
   * The method to use when sending events. Defaults to POST.
   * @return method
  **/
  @Schema(description = "The method to use when sending events. Defaults to POST.")
  public MethodEnum getMethod() {
    return method;
  }

  public void setMethod(MethodEnum method) {
    this.method = method;
  }

  public OutputHoneycomb topicName(String topicName) {
    this.topicName = topicName;
    return this;
  }

   /**
   * ID of the topic to send events to.
   * @return topicName
  **/
  @Schema(description = "ID of the topic to send events to.")
  public String getTopicName() {
    return topicName;
  }

  public void setTopicName(String topicName) {
    this.topicName = topicName;
  }

  public OutputHoneycomb createTopic(Boolean createTopic) {
    this.createTopic = createTopic;
    return this;
  }

   /**
   * If enabled, create topic if it does not exist.
   * @return createTopic
  **/
  @Schema(description = "If enabled, create topic if it does not exist.")
  public Boolean isCreateTopic() {
    return createTopic;
  }

  public void setCreateTopic(Boolean createTopic) {
    this.createTopic = createTopic;
  }

  public OutputHoneycomb orderedDelivery(Boolean orderedDelivery) {
    this.orderedDelivery = orderedDelivery;
    return this;
  }

   /**
   * If enabled, send events in the order they were added to the queue. For this to work correctly, the process receiving events must have ordering enabled.
   * @return orderedDelivery
  **/
  @Schema(description = "If enabled, send events in the order they were added to the queue. For this to work correctly, the process receiving events must have ordering enabled.")
  public Boolean isOrderedDelivery() {
    return orderedDelivery;
  }

  public void setOrderedDelivery(Boolean orderedDelivery) {
    this.orderedDelivery = orderedDelivery;
  }

  public OutputHoneycomb googleAuthMethod(GoogleAuthMethodEnum googleAuthMethod) {
    this.googleAuthMethod = googleAuthMethod;
    return this;
  }

   /**
   * Google authentication method. Choose Auto to use environment variables PUBSUB_PROJECT and PUBSUB_CREDENTIALS.
   * @return googleAuthMethod
  **/
  @Schema(description = "Google authentication method. Choose Auto to use environment variables PUBSUB_PROJECT and PUBSUB_CREDENTIALS.")
  public GoogleAuthMethodEnum getGoogleAuthMethod() {
    return googleAuthMethod;
  }

  public void setGoogleAuthMethod(GoogleAuthMethodEnum googleAuthMethod) {
    this.googleAuthMethod = googleAuthMethod;
  }

  public OutputHoneycomb serviceAccountCredentials(Object serviceAccountCredentials) {
    this.serviceAccountCredentials = serviceAccountCredentials;
    return this;
  }

   /**
   * Get serviceAccountCredentials
   * @return serviceAccountCredentials
  **/
  @Schema(description = "")
  public Object getServiceAccountCredentials() {
    return serviceAccountCredentials;
  }

  public void setServiceAccountCredentials(Object serviceAccountCredentials) {
    this.serviceAccountCredentials = serviceAccountCredentials;
  }

  public OutputHoneycomb secret(Object secret) {
    this.secret = secret;
    return this;
  }

   /**
   * Get secret
   * @return secret
  **/
  @Schema(description = "")
  public Object getSecret() {
    return secret;
  }

  public void setSecret(Object secret) {
    this.secret = secret;
  }

  public OutputHoneycomb batchSize(BigDecimal batchSize) {
    this.batchSize = batchSize;
    return this;
  }

   /**
   * The maximum number of items the Google API should batch before it sends them to the topic.
   * minimum: 1
   * maximum: 10000
   * @return batchSize
  **/
  @Schema(description = "The maximum number of items the Google API should batch before it sends them to the topic.")
  public BigDecimal getBatchSize() {
    return batchSize;
  }

  public void setBatchSize(BigDecimal batchSize) {
    this.batchSize = batchSize;
  }

  public OutputHoneycomb batchTimeout(BigDecimal batchTimeout) {
    this.batchTimeout = batchTimeout;
    return this;
  }

   /**
   * The maximum amount of time, in milliseconds, that the Google API should wait to send a batch (if the Batch size is not reached).
   * minimum: 1
   * maximum: 100000
   * @return batchTimeout
  **/
  @Schema(description = "The maximum amount of time, in milliseconds, that the Google API should wait to send a batch (if the Batch size is not reached).")
  public BigDecimal getBatchTimeout() {
    return batchTimeout;
  }

  public void setBatchTimeout(BigDecimal batchTimeout) {
    this.batchTimeout = batchTimeout;
  }

  public OutputHoneycomb authenticationMethod(AuthenticationMethodEnum authenticationMethod) {
    this.authenticationMethod = authenticationMethod;
    return this;
  }

   /**
   * Get authenticationMethod
   * @return authenticationMethod
  **/
  @Schema(description = "")
  public AuthenticationMethodEnum getAuthenticationMethod() {
    return authenticationMethod;
  }

  public void setAuthenticationMethod(AuthenticationMethodEnum authenticationMethod) {
    this.authenticationMethod = authenticationMethod;
  }

  public OutputHoneycomb logTextField(String logTextField) {
    this.logTextField = logTextField;
    return this;
  }

   /**
   * Name of the event field that contains the log text to send. If not specified, LogStream sends a JSON representation of the whole event.
   * @return logTextField
  **/
  @Schema(description = "Name of the event field that contains the log text to send. If not specified, LogStream sends a JSON representation of the whole event.")
  public String getLogTextField() {
    return logTextField;
  }

  public void setLogTextField(String logTextField) {
    this.logTextField = logTextField;
  }

  public OutputHoneycomb logFormatType(LogFormatTypeEnum logFormatType) {
    this.logFormatType = logFormatType;
    return this;
  }

   /**
   * Get logFormatType
   * @return logFormatType
  **/
  @Schema(description = "")
  public LogFormatTypeEnum getLogFormatType() {
    return logFormatType;
  }

  public void setLogFormatType(LogFormatTypeEnum logFormatType) {
    this.logFormatType = logFormatType;
  }

  public OutputHoneycomb lokiUrl(String lokiUrl) {
    this.lokiUrl = lokiUrl;
    return this;
  }

   /**
   * The endpoint to send logs to.
   * @return lokiUrl
  **/
  @Schema(description = "The endpoint to send logs to.")
  public String getLokiUrl() {
    return lokiUrl;
  }

  public void setLokiUrl(String lokiUrl) {
    this.lokiUrl = lokiUrl;
  }

  public OutputHoneycomb prometheusUrl(String prometheusUrl) {
    this.prometheusUrl = prometheusUrl;
    return this;
  }

   /**
   * The remote_write endpoint to send Prometheus metrics to.
   * @return prometheusUrl
  **/
  @Schema(description = "The remote_write endpoint to send Prometheus metrics to.")
  public String getPrometheusUrl() {
    return prometheusUrl;
  }

  public void setPrometheusUrl(String prometheusUrl) {
    this.prometheusUrl = prometheusUrl;
  }

  public OutputHoneycomb labels(List<OutputDefaultLabels> labels) {
    this.labels = labels;
    return this;
  }

  public OutputHoneycomb addLabelsItem(OutputDefaultLabels labelsItem) {
    if (this.labels == null) {
      this.labels = new ArrayList<>();
    }
    this.labels.add(labelsItem);
    return this;
  }

   /**
   * List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the event&#x27;s __labels field (e.g.: &#x27;__labels: {host: \&quot;cribl.io\&quot;, level: \&quot;error\&quot;}&#x27;).
   * @return labels
  **/
  @Schema(description = "List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the event's __labels field (e.g.: '__labels: {host: \"cribl.io\", level: \"error\"}').")
  public List<OutputDefaultLabels> getLabels() {
    return labels;
  }

  public void setLabels(List<OutputDefaultLabels> labels) {
    this.labels = labels;
  }

  public OutputHoneycomb prometheusAuth(OutputDefaultPrometheusAuth prometheusAuth) {
    this.prometheusAuth = prometheusAuth;
    return this;
  }

   /**
   * Get prometheusAuth
   * @return prometheusAuth
  **/
  @Schema(description = "")
  public OutputDefaultPrometheusAuth getPrometheusAuth() {
    return prometheusAuth;
  }

  public void setPrometheusAuth(OutputDefaultPrometheusAuth prometheusAuth) {
    this.prometheusAuth = prometheusAuth;
  }

  public OutputHoneycomb lokiAuth(OutputDefaultPrometheusAuth lokiAuth) {
    this.lokiAuth = lokiAuth;
    return this;
  }

   /**
   * Get lokiAuth
   * @return lokiAuth
  **/
  @Schema(description = "")
  public OutputDefaultPrometheusAuth getLokiAuth() {
    return lokiAuth;
  }

  public void setLokiAuth(OutputDefaultPrometheusAuth lokiAuth) {
    this.lokiAuth = lokiAuth;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OutputHoneycomb outputHoneycomb = (OutputHoneycomb) o;
    return Objects.equals(this.id, outputHoneycomb.id) &&
        Objects.equals(this.type, outputHoneycomb.type) &&
        Objects.equals(this.pipeline, outputHoneycomb.pipeline) &&
        Objects.equals(this.systemFields, outputHoneycomb.systemFields) &&
        Objects.equals(this.defaultId, outputHoneycomb.defaultId) &&
        Objects.equals(this.host, outputHoneycomb.host) &&
        Objects.equals(this.port, outputHoneycomb.port) &&
        Objects.equals(this.compression, outputHoneycomb.compression) &&
        Objects.equals(this.throttleRatePerSec, outputHoneycomb.throttleRatePerSec) &&
        Objects.equals(this.tls, outputHoneycomb.tls) &&
        Objects.equals(this.connectionTimeout, outputHoneycomb.connectionTimeout) &&
        Objects.equals(this.writeTimeout, outputHoneycomb.writeTimeout) &&
        Objects.equals(this.onBackpressure, outputHoneycomb.onBackpressure) &&
        Objects.equals(this.authType, outputHoneycomb.authType) &&
        Objects.equals(this.protocol, outputHoneycomb.protocol) &&
        Objects.equals(this.facility, outputHoneycomb.facility) &&
        Objects.equals(this.severity, outputHoneycomb.severity) &&
        Objects.equals(this.appName, outputHoneycomb.appName) &&
        Objects.equals(this.messageFormat, outputHoneycomb.messageFormat) &&
        Objects.equals(this.timestampFormat, outputHoneycomb.timestampFormat) &&
        Objects.equals(this.nestedFields, outputHoneycomb.nestedFields) &&
        Objects.equals(this.enableMultiMetrics, outputHoneycomb.enableMultiMetrics) &&
        Objects.equals(this.enableACK, outputHoneycomb.enableACK) &&
        Objects.equals(this.dnsResolvePeriodSec, outputHoneycomb.dnsResolvePeriodSec) &&
        Objects.equals(this.loadBalanceStatsPeriodSec, outputHoneycomb.loadBalanceStatsPeriodSec) &&
        Objects.equals(this.maxConcurrentSenders, outputHoneycomb.maxConcurrentSenders) &&
        Objects.equals(this.indexerDiscovery, outputHoneycomb.indexerDiscovery) &&
        Objects.equals(this.url, outputHoneycomb.url) &&
        Objects.equals(this.nextQueue, outputHoneycomb.nextQueue) &&
        Objects.equals(this.tcpRouting, outputHoneycomb.tcpRouting) &&
        Objects.equals(this.concurrency, outputHoneycomb.concurrency) &&
        Objects.equals(this.maxPayloadSizeKB, outputHoneycomb.maxPayloadSizeKB) &&
        Objects.equals(this.maxPayloadEvents, outputHoneycomb.maxPayloadEvents) &&
        Objects.equals(this.compress, outputHoneycomb.compress) &&
        Objects.equals(this.rejectUnauthorized, outputHoneycomb.rejectUnauthorized) &&
        Objects.equals(this.timeoutSec, outputHoneycomb.timeoutSec) &&
        Objects.equals(this.flushPeriodSec, outputHoneycomb.flushPeriodSec) &&
        Objects.equals(this.extraHttpHeaders, outputHoneycomb.extraHttpHeaders) &&
        Objects.equals(this.useRoundRobinDns, outputHoneycomb.useRoundRobinDns) &&
        Objects.equals(this.domain, outputHoneycomb.domain) &&
        Objects.equals(this.realm, outputHoneycomb.realm) &&
        Objects.equals(this.destPath, outputHoneycomb.destPath) &&
        Objects.equals(this.stagePath, outputHoneycomb.stagePath) &&
        Objects.equals(this.addIdToStagePath, outputHoneycomb.addIdToStagePath) &&
        Objects.equals(this.removeEmptyDirs, outputHoneycomb.removeEmptyDirs) &&
        Objects.equals(this.partitionExpr, outputHoneycomb.partitionExpr) &&
        Objects.equals(this.format, outputHoneycomb.format) &&
        Objects.equals(this.baseFileName, outputHoneycomb.baseFileName) &&
        Objects.equals(this.maxFileSizeMB, outputHoneycomb.maxFileSizeMB) &&
        Objects.equals(this.maxFileOpenTimeSec, outputHoneycomb.maxFileOpenTimeSec) &&
        Objects.equals(this.maxFileIdleTimeSec, outputHoneycomb.maxFileIdleTimeSec) &&
        Objects.equals(this.maxOpenFiles, outputHoneycomb.maxOpenFiles) &&
        Objects.equals(this.bucket, outputHoneycomb.bucket) &&
        Objects.equals(this.region, outputHoneycomb.region) &&
        Objects.equals(this.awsAuthenticationMethod, outputHoneycomb.awsAuthenticationMethod) &&
        Objects.equals(this.awsSecretKey, outputHoneycomb.awsSecretKey) &&
        Objects.equals(this.endpoint, outputHoneycomb.endpoint) &&
        Objects.equals(this.signatureVersion, outputHoneycomb.signatureVersion) &&
        Objects.equals(this.reuseConnections, outputHoneycomb.reuseConnections) &&
        Objects.equals(this.enableAssumeRole, outputHoneycomb.enableAssumeRole) &&
        Objects.equals(this.assumeRoleArn, outputHoneycomb.assumeRoleArn) &&
        Objects.equals(this.assumeRoleExternalId, outputHoneycomb.assumeRoleExternalId) &&
        Objects.equals(this.objectACL, outputHoneycomb.objectACL) &&
        Objects.equals(this.storageClass, outputHoneycomb.storageClass) &&
        Objects.equals(this.serverSideEncryption, outputHoneycomb.serverSideEncryption) &&
        Objects.equals(this.kmsKeyId, outputHoneycomb.kmsKeyId) &&
        Objects.equals(this.containerName, outputHoneycomb.containerName) &&
        Objects.equals(this.createContainer, outputHoneycomb.createContainer) &&
        Objects.equals(this.logType, outputHoneycomb.logType) &&
        Objects.equals(this.resourceId, outputHoneycomb.resourceId) &&
        Objects.equals(this.streamName, outputHoneycomb.streamName) &&
        Objects.equals(this.maxRecordSizeKB, outputHoneycomb.maxRecordSizeKB) &&
        Objects.equals(this.dataset, outputHoneycomb.dataset) &&
        Objects.equals(this.messageField, outputHoneycomb.messageField) &&
        Objects.equals(this.metadata, outputHoneycomb.metadata) &&
        Objects.equals(this.accountId, outputHoneycomb.accountId) &&
        Objects.equals(this.eventType, outputHoneycomb.eventType) &&
        Objects.equals(this.index, outputHoneycomb.index) &&
        Objects.equals(this.docType, outputHoneycomb.docType) &&
        Objects.equals(this.auth, outputHoneycomb.auth) &&
        Objects.equals(this.elasticVersion, outputHoneycomb.elasticVersion) &&
        Objects.equals(this.brokers, outputHoneycomb.brokers) &&
        Objects.equals(this.topic, outputHoneycomb.topic) &&
        Objects.equals(this.ack, outputHoneycomb.ack) &&
        Objects.equals(this.flushEventCount, outputHoneycomb.flushEventCount) &&
        Objects.equals(this.kafkaSchemaRegistry, outputHoneycomb.kafkaSchemaRegistry) &&
        Objects.equals(this.sasl, outputHoneycomb.sasl) &&
        Objects.equals(this.database, outputHoneycomb.database) &&
        Objects.equals(this.timestampPrecision, outputHoneycomb.timestampPrecision) &&
        Objects.equals(this.dynamicValueFieldName, outputHoneycomb.dynamicValueFieldName) &&
        Objects.equals(this.valueFieldName, outputHoneycomb.valueFieldName) &&
        Objects.equals(this.logGroupName, outputHoneycomb.logGroupName) &&
        Objects.equals(this.logStreamName, outputHoneycomb.logStreamName) &&
        Objects.equals(this.maxQueueSize, outputHoneycomb.maxQueueSize) &&
        Objects.equals(this.mtu, outputHoneycomb.mtu) &&
        Objects.equals(this.rules, outputHoneycomb.rules) &&
        Objects.equals(this.queueName, outputHoneycomb.queueName) &&
        Objects.equals(this.queueType, outputHoneycomb.queueType) &&
        Objects.equals(this.awsAccountId, outputHoneycomb.awsAccountId) &&
        Objects.equals(this.messageGroupId, outputHoneycomb.messageGroupId) &&
        Objects.equals(this.createQueue, outputHoneycomb.createQueue) &&
        Objects.equals(this.maxInProgress, outputHoneycomb.maxInProgress) &&
        Objects.equals(this.hosts, outputHoneycomb.hosts) &&
        Objects.equals(this.customSource, outputHoneycomb.customSource) &&
        Objects.equals(this.customCategory, outputHoneycomb.customCategory) &&
        Objects.equals(this.contentType, outputHoneycomb.contentType) &&
        Objects.equals(this.message, outputHoneycomb.message) &&
        Objects.equals(this.source, outputHoneycomb.source) &&
        Objects.equals(this.service, outputHoneycomb.service) &&
        Objects.equals(this.tags, outputHoneycomb.tags) &&
        Objects.equals(this.metricRenameExpr, outputHoneycomb.metricRenameExpr) &&
        Objects.equals(this.sendMetadata, outputHoneycomb.sendMetadata) &&
        Objects.equals(this.method, outputHoneycomb.method) &&
        Objects.equals(this.topicName, outputHoneycomb.topicName) &&
        Objects.equals(this.createTopic, outputHoneycomb.createTopic) &&
        Objects.equals(this.orderedDelivery, outputHoneycomb.orderedDelivery) &&
        Objects.equals(this.googleAuthMethod, outputHoneycomb.googleAuthMethod) &&
        Objects.equals(this.serviceAccountCredentials, outputHoneycomb.serviceAccountCredentials) &&
        Objects.equals(this.secret, outputHoneycomb.secret) &&
        Objects.equals(this.batchSize, outputHoneycomb.batchSize) &&
        Objects.equals(this.batchTimeout, outputHoneycomb.batchTimeout) &&
        Objects.equals(this.authenticationMethod, outputHoneycomb.authenticationMethod) &&
        Objects.equals(this.logTextField, outputHoneycomb.logTextField) &&
        Objects.equals(this.logFormatType, outputHoneycomb.logFormatType) &&
        Objects.equals(this.lokiUrl, outputHoneycomb.lokiUrl) &&
        Objects.equals(this.prometheusUrl, outputHoneycomb.prometheusUrl) &&
        Objects.equals(this.labels, outputHoneycomb.labels) &&
        Objects.equals(this.prometheusAuth, outputHoneycomb.prometheusAuth) &&
        Objects.equals(this.lokiAuth, outputHoneycomb.lokiAuth);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, type, pipeline, systemFields, defaultId, host, port, compression, throttleRatePerSec, tls, connectionTimeout, writeTimeout, onBackpressure, authType, protocol, facility, severity, appName, messageFormat, timestampFormat, nestedFields, enableMultiMetrics, enableACK, dnsResolvePeriodSec, loadBalanceStatsPeriodSec, maxConcurrentSenders, indexerDiscovery, url, nextQueue, tcpRouting, concurrency, maxPayloadSizeKB, maxPayloadEvents, compress, rejectUnauthorized, timeoutSec, flushPeriodSec, extraHttpHeaders, useRoundRobinDns, domain, realm, destPath, stagePath, addIdToStagePath, removeEmptyDirs, partitionExpr, format, baseFileName, maxFileSizeMB, maxFileOpenTimeSec, maxFileIdleTimeSec, maxOpenFiles, bucket, region, awsAuthenticationMethod, awsSecretKey, endpoint, signatureVersion, reuseConnections, enableAssumeRole, assumeRoleArn, assumeRoleExternalId, objectACL, storageClass, serverSideEncryption, kmsKeyId, containerName, createContainer, logType, resourceId, streamName, maxRecordSizeKB, dataset, messageField, metadata, accountId, eventType, index, docType, auth, elasticVersion, brokers, topic, ack, flushEventCount, kafkaSchemaRegistry, sasl, database, timestampPrecision, dynamicValueFieldName, valueFieldName, logGroupName, logStreamName, maxQueueSize, mtu, rules, queueName, queueType, awsAccountId, messageGroupId, createQueue, maxInProgress, hosts, customSource, customCategory, contentType, message, source, service, tags, metricRenameExpr, sendMetadata, method, topicName, createTopic, orderedDelivery, googleAuthMethod, serviceAccountCredentials, secret, batchSize, batchTimeout, authenticationMethod, logTextField, logFormatType, lokiUrl, prometheusUrl, labels, prometheusAuth, lokiAuth);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OutputHoneycomb {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    pipeline: ").append(toIndentedString(pipeline)).append("\n");
    sb.append("    systemFields: ").append(toIndentedString(systemFields)).append("\n");
    sb.append("    defaultId: ").append(toIndentedString(defaultId)).append("\n");
    sb.append("    host: ").append(toIndentedString(host)).append("\n");
    sb.append("    port: ").append(toIndentedString(port)).append("\n");
    sb.append("    compression: ").append(toIndentedString(compression)).append("\n");
    sb.append("    throttleRatePerSec: ").append(toIndentedString(throttleRatePerSec)).append("\n");
    sb.append("    tls: ").append(toIndentedString(tls)).append("\n");
    sb.append("    connectionTimeout: ").append(toIndentedString(connectionTimeout)).append("\n");
    sb.append("    writeTimeout: ").append(toIndentedString(writeTimeout)).append("\n");
    sb.append("    onBackpressure: ").append(toIndentedString(onBackpressure)).append("\n");
    sb.append("    authType: ").append(toIndentedString(authType)).append("\n");
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    facility: ").append(toIndentedString(facility)).append("\n");
    sb.append("    severity: ").append(toIndentedString(severity)).append("\n");
    sb.append("    appName: ").append(toIndentedString(appName)).append("\n");
    sb.append("    messageFormat: ").append(toIndentedString(messageFormat)).append("\n");
    sb.append("    timestampFormat: ").append(toIndentedString(timestampFormat)).append("\n");
    sb.append("    nestedFields: ").append(toIndentedString(nestedFields)).append("\n");
    sb.append("    enableMultiMetrics: ").append(toIndentedString(enableMultiMetrics)).append("\n");
    sb.append("    enableACK: ").append(toIndentedString(enableACK)).append("\n");
    sb.append("    dnsResolvePeriodSec: ").append(toIndentedString(dnsResolvePeriodSec)).append("\n");
    sb.append("    loadBalanceStatsPeriodSec: ").append(toIndentedString(loadBalanceStatsPeriodSec)).append("\n");
    sb.append("    maxConcurrentSenders: ").append(toIndentedString(maxConcurrentSenders)).append("\n");
    sb.append("    indexerDiscovery: ").append(toIndentedString(indexerDiscovery)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    nextQueue: ").append(toIndentedString(nextQueue)).append("\n");
    sb.append("    tcpRouting: ").append(toIndentedString(tcpRouting)).append("\n");
    sb.append("    concurrency: ").append(toIndentedString(concurrency)).append("\n");
    sb.append("    maxPayloadSizeKB: ").append(toIndentedString(maxPayloadSizeKB)).append("\n");
    sb.append("    maxPayloadEvents: ").append(toIndentedString(maxPayloadEvents)).append("\n");
    sb.append("    compress: ").append(toIndentedString(compress)).append("\n");
    sb.append("    rejectUnauthorized: ").append(toIndentedString(rejectUnauthorized)).append("\n");
    sb.append("    timeoutSec: ").append(toIndentedString(timeoutSec)).append("\n");
    sb.append("    flushPeriodSec: ").append(toIndentedString(flushPeriodSec)).append("\n");
    sb.append("    extraHttpHeaders: ").append(toIndentedString(extraHttpHeaders)).append("\n");
    sb.append("    useRoundRobinDns: ").append(toIndentedString(useRoundRobinDns)).append("\n");
    sb.append("    domain: ").append(toIndentedString(domain)).append("\n");
    sb.append("    realm: ").append(toIndentedString(realm)).append("\n");
    sb.append("    destPath: ").append(toIndentedString(destPath)).append("\n");
    sb.append("    stagePath: ").append(toIndentedString(stagePath)).append("\n");
    sb.append("    addIdToStagePath: ").append(toIndentedString(addIdToStagePath)).append("\n");
    sb.append("    removeEmptyDirs: ").append(toIndentedString(removeEmptyDirs)).append("\n");
    sb.append("    partitionExpr: ").append(toIndentedString(partitionExpr)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    baseFileName: ").append(toIndentedString(baseFileName)).append("\n");
    sb.append("    maxFileSizeMB: ").append(toIndentedString(maxFileSizeMB)).append("\n");
    sb.append("    maxFileOpenTimeSec: ").append(toIndentedString(maxFileOpenTimeSec)).append("\n");
    sb.append("    maxFileIdleTimeSec: ").append(toIndentedString(maxFileIdleTimeSec)).append("\n");
    sb.append("    maxOpenFiles: ").append(toIndentedString(maxOpenFiles)).append("\n");
    sb.append("    bucket: ").append(toIndentedString(bucket)).append("\n");
    sb.append("    region: ").append(toIndentedString(region)).append("\n");
    sb.append("    awsAuthenticationMethod: ").append(toIndentedString(awsAuthenticationMethod)).append("\n");
    sb.append("    awsSecretKey: ").append(toIndentedString(awsSecretKey)).append("\n");
    sb.append("    endpoint: ").append(toIndentedString(endpoint)).append("\n");
    sb.append("    signatureVersion: ").append(toIndentedString(signatureVersion)).append("\n");
    sb.append("    reuseConnections: ").append(toIndentedString(reuseConnections)).append("\n");
    sb.append("    enableAssumeRole: ").append(toIndentedString(enableAssumeRole)).append("\n");
    sb.append("    assumeRoleArn: ").append(toIndentedString(assumeRoleArn)).append("\n");
    sb.append("    assumeRoleExternalId: ").append(toIndentedString(assumeRoleExternalId)).append("\n");
    sb.append("    objectACL: ").append(toIndentedString(objectACL)).append("\n");
    sb.append("    storageClass: ").append(toIndentedString(storageClass)).append("\n");
    sb.append("    serverSideEncryption: ").append(toIndentedString(serverSideEncryption)).append("\n");
    sb.append("    kmsKeyId: ").append(toIndentedString(kmsKeyId)).append("\n");
    sb.append("    containerName: ").append(toIndentedString(containerName)).append("\n");
    sb.append("    createContainer: ").append(toIndentedString(createContainer)).append("\n");
    sb.append("    logType: ").append(toIndentedString(logType)).append("\n");
    sb.append("    resourceId: ").append(toIndentedString(resourceId)).append("\n");
    sb.append("    streamName: ").append(toIndentedString(streamName)).append("\n");
    sb.append("    maxRecordSizeKB: ").append(toIndentedString(maxRecordSizeKB)).append("\n");
    sb.append("    dataset: ").append(toIndentedString(dataset)).append("\n");
    sb.append("    messageField: ").append(toIndentedString(messageField)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    accountId: ").append(toIndentedString(accountId)).append("\n");
    sb.append("    eventType: ").append(toIndentedString(eventType)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    docType: ").append(toIndentedString(docType)).append("\n");
    sb.append("    auth: ").append(toIndentedString(auth)).append("\n");
    sb.append("    elasticVersion: ").append(toIndentedString(elasticVersion)).append("\n");
    sb.append("    brokers: ").append(toIndentedString(brokers)).append("\n");
    sb.append("    topic: ").append(toIndentedString(topic)).append("\n");
    sb.append("    ack: ").append(toIndentedString(ack)).append("\n");
    sb.append("    flushEventCount: ").append(toIndentedString(flushEventCount)).append("\n");
    sb.append("    kafkaSchemaRegistry: ").append(toIndentedString(kafkaSchemaRegistry)).append("\n");
    sb.append("    sasl: ").append(toIndentedString(sasl)).append("\n");
    sb.append("    database: ").append(toIndentedString(database)).append("\n");
    sb.append("    timestampPrecision: ").append(toIndentedString(timestampPrecision)).append("\n");
    sb.append("    dynamicValueFieldName: ").append(toIndentedString(dynamicValueFieldName)).append("\n");
    sb.append("    valueFieldName: ").append(toIndentedString(valueFieldName)).append("\n");
    sb.append("    logGroupName: ").append(toIndentedString(logGroupName)).append("\n");
    sb.append("    logStreamName: ").append(toIndentedString(logStreamName)).append("\n");
    sb.append("    maxQueueSize: ").append(toIndentedString(maxQueueSize)).append("\n");
    sb.append("    mtu: ").append(toIndentedString(mtu)).append("\n");
    sb.append("    rules: ").append(toIndentedString(rules)).append("\n");
    sb.append("    queueName: ").append(toIndentedString(queueName)).append("\n");
    sb.append("    queueType: ").append(toIndentedString(queueType)).append("\n");
    sb.append("    awsAccountId: ").append(toIndentedString(awsAccountId)).append("\n");
    sb.append("    messageGroupId: ").append(toIndentedString(messageGroupId)).append("\n");
    sb.append("    createQueue: ").append(toIndentedString(createQueue)).append("\n");
    sb.append("    maxInProgress: ").append(toIndentedString(maxInProgress)).append("\n");
    sb.append("    hosts: ").append(toIndentedString(hosts)).append("\n");
    sb.append("    customSource: ").append(toIndentedString(customSource)).append("\n");
    sb.append("    customCategory: ").append(toIndentedString(customCategory)).append("\n");
    sb.append("    contentType: ").append(toIndentedString(contentType)).append("\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    service: ").append(toIndentedString(service)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    metricRenameExpr: ").append(toIndentedString(metricRenameExpr)).append("\n");
    sb.append("    sendMetadata: ").append(toIndentedString(sendMetadata)).append("\n");
    sb.append("    method: ").append(toIndentedString(method)).append("\n");
    sb.append("    topicName: ").append(toIndentedString(topicName)).append("\n");
    sb.append("    createTopic: ").append(toIndentedString(createTopic)).append("\n");
    sb.append("    orderedDelivery: ").append(toIndentedString(orderedDelivery)).append("\n");
    sb.append("    googleAuthMethod: ").append(toIndentedString(googleAuthMethod)).append("\n");
    sb.append("    serviceAccountCredentials: ").append(toIndentedString(serviceAccountCredentials)).append("\n");
    sb.append("    secret: ").append(toIndentedString(secret)).append("\n");
    sb.append("    batchSize: ").append(toIndentedString(batchSize)).append("\n");
    sb.append("    batchTimeout: ").append(toIndentedString(batchTimeout)).append("\n");
    sb.append("    authenticationMethod: ").append(toIndentedString(authenticationMethod)).append("\n");
    sb.append("    logTextField: ").append(toIndentedString(logTextField)).append("\n");
    sb.append("    logFormatType: ").append(toIndentedString(logFormatType)).append("\n");
    sb.append("    lokiUrl: ").append(toIndentedString(lokiUrl)).append("\n");
    sb.append("    prometheusUrl: ").append(toIndentedString(prometheusUrl)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    prometheusAuth: ").append(toIndentedString(prometheusAuth)).append("\n");
    sb.append("    lokiAuth: ").append(toIndentedString(lokiAuth)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
