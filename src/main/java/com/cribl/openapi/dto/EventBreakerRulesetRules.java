/*
 * Cribl LogStream
 * REST API Reference of available endpoints and their supported operations for accessing, updating, creating, or deleting resources. Product documentation available at [docs.cribl.io](http://docs.cribl.io).
 *
 * OpenAPI spec version: 3.1.2-abb571bc
 * Contact: support@cribl.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.cribl.openapi.dto;

import java.util.Objects;
import java.util.Arrays;
import com.cribl.openapi.dto.EventBreakerRulesetFields;
import com.cribl.openapi.dto.TimestampFormat;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
/**
 * EventBreakerRulesetRules
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2021-10-08T00:23:34.796-04:00[America/New_York]")
public class EventBreakerRulesetRules {
  @SerializedName("name")
  private String name = null;

  @SerializedName("condition")
  private String condition = "true";

  /**
   * Event Breaker Type
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    REGEX("regex"),
    JSON("json"),
    JSON_ARRAY("json_array"),
    HEADER("header"),
    TIMESTAMP("timestamp"),
    CSV("csv");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TypeEnum fromValue(String text) {
      for (TypeEnum b : TypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return TypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("type")
  private TypeEnum type = TypeEnum.REGEX;

  @SerializedName("timestampAnchorRegex")
  private String timestampAnchorRegex = "/^/";

  @SerializedName("timestamp")
  private TimestampFormat timestamp = null;

  @SerializedName("timestampTimezone")
  private String timestampTimezone = "local";

  @SerializedName("timestampEarliest")
  private String timestampEarliest = "-420weeks";

  @SerializedName("timestampLatest")
  private String timestampLatest = "+1week";

  @SerializedName("maxEventBytes")
  private BigDecimal maxEventBytes = new BigDecimal(51200);

  @SerializedName("fields")
  private List<EventBreakerRulesetFields> fields = null;

  @SerializedName("disabled")
  private Boolean disabled = false;

  public EventBreakerRulesetRules name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Rule Name.
   * @return name
  **/
  @Schema(required = true, description = "Rule Name.")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public EventBreakerRulesetRules condition(String condition) {
    this.condition = condition;
    return this;
  }

   /**
   * Filter expression (JS) that matches data to apply rule to. To test your sample, use the maximize icon on the right.
   * @return condition
  **/
  @Schema(required = true, description = "Filter expression (JS) that matches data to apply rule to. To test your sample, use the maximize icon on the right.")
  public String getCondition() {
    return condition;
  }

  public void setCondition(String condition) {
    this.condition = condition;
  }

  public EventBreakerRulesetRules type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * Event Breaker Type
   * @return type
  **/
  @Schema(required = true, description = "Event Breaker Type")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public EventBreakerRulesetRules timestampAnchorRegex(String timestampAnchorRegex) {
    this.timestampAnchorRegex = timestampAnchorRegex;
    return this;
  }

   /**
   * Regex to match before attempting timestamp extraction. Use $ (end of string anchor) to not perform extraction.
   * @return timestampAnchorRegex
  **/
  @Schema(required = true, description = "Regex to match before attempting timestamp extraction. Use $ (end of string anchor) to not perform extraction.")
  public String getTimestampAnchorRegex() {
    return timestampAnchorRegex;
  }

  public void setTimestampAnchorRegex(String timestampAnchorRegex) {
    this.timestampAnchorRegex = timestampAnchorRegex;
  }

  public EventBreakerRulesetRules timestamp(TimestampFormat timestamp) {
    this.timestamp = timestamp;
    return this;
  }

   /**
   * Get timestamp
   * @return timestamp
  **/
  @Schema(required = true, description = "")
  public TimestampFormat getTimestamp() {
    return timestamp;
  }

  public void setTimestamp(TimestampFormat timestamp) {
    this.timestamp = timestamp;
  }

  public EventBreakerRulesetRules timestampTimezone(String timestampTimezone) {
    this.timestampTimezone = timestampTimezone;
    return this;
  }

   /**
   * Timezone to assign to timestamps without timezone info.
   * @return timestampTimezone
  **/
  @Schema(description = "Timezone to assign to timestamps without timezone info.")
  public String getTimestampTimezone() {
    return timestampTimezone;
  }

  public void setTimestampTimezone(String timestampTimezone) {
    this.timestampTimezone = timestampTimezone;
  }

  public EventBreakerRulesetRules timestampEarliest(String timestampEarliest) {
    this.timestampEarliest = timestampEarliest;
    return this;
  }

   /**
   * The earliest timestamp value allowed relative to now. E.g., -42years. Parsed values prior to this date will be set to current time.
   * @return timestampEarliest
  **/
  @Schema(description = "The earliest timestamp value allowed relative to now. E.g., -42years. Parsed values prior to this date will be set to current time.")
  public String getTimestampEarliest() {
    return timestampEarliest;
  }

  public void setTimestampEarliest(String timestampEarliest) {
    this.timestampEarliest = timestampEarliest;
  }

  public EventBreakerRulesetRules timestampLatest(String timestampLatest) {
    this.timestampLatest = timestampLatest;
    return this;
  }

   /**
   * The latest timestamp value allowed relative to now. E.g., +42days. Parsed values after this date will be set to current time.
   * @return timestampLatest
  **/
  @Schema(description = "The latest timestamp value allowed relative to now. E.g., +42days. Parsed values after this date will be set to current time.")
  public String getTimestampLatest() {
    return timestampLatest;
  }

  public void setTimestampLatest(String timestampLatest) {
    this.timestampLatest = timestampLatest;
  }

  public EventBreakerRulesetRules maxEventBytes(BigDecimal maxEventBytes) {
    this.maxEventBytes = maxEventBytes;
    return this;
  }

   /**
   * The maximum number of bytes that an event can be before being flushed to the pipelines
   * minimum: 1
   * maximum: 134217728
   * @return maxEventBytes
  **/
  @Schema(description = "The maximum number of bytes that an event can be before being flushed to the pipelines")
  public BigDecimal getMaxEventBytes() {
    return maxEventBytes;
  }

  public void setMaxEventBytes(BigDecimal maxEventBytes) {
    this.maxEventBytes = maxEventBytes;
  }

  public EventBreakerRulesetRules fields(List<EventBreakerRulesetFields> fields) {
    this.fields = fields;
    return this;
  }

  public EventBreakerRulesetRules addFieldsItem(EventBreakerRulesetFields fieldsItem) {
    if (this.fields == null) {
      this.fields = new ArrayList<>();
    }
    this.fields.add(fieldsItem);
    return this;
  }

   /**
   * Key value pairs to be added to each event.
   * @return fields
  **/
  @Schema(description = "Key value pairs to be added to each event.")
  public List<EventBreakerRulesetFields> getFields() {
    return fields;
  }

  public void setFields(List<EventBreakerRulesetFields> fields) {
    this.fields = fields;
  }

  public EventBreakerRulesetRules disabled(Boolean disabled) {
    this.disabled = disabled;
    return this;
  }

   /**
   * Allows breaker rule to be enabled or disabled, default is enabled.
   * @return disabled
  **/
  @Schema(description = "Allows breaker rule to be enabled or disabled, default is enabled.")
  public Boolean isDisabled() {
    return disabled;
  }

  public void setDisabled(Boolean disabled) {
    this.disabled = disabled;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EventBreakerRulesetRules eventBreakerRulesetRules = (EventBreakerRulesetRules) o;
    return Objects.equals(this.name, eventBreakerRulesetRules.name) &&
        Objects.equals(this.condition, eventBreakerRulesetRules.condition) &&
        Objects.equals(this.type, eventBreakerRulesetRules.type) &&
        Objects.equals(this.timestampAnchorRegex, eventBreakerRulesetRules.timestampAnchorRegex) &&
        Objects.equals(this.timestamp, eventBreakerRulesetRules.timestamp) &&
        Objects.equals(this.timestampTimezone, eventBreakerRulesetRules.timestampTimezone) &&
        Objects.equals(this.timestampEarliest, eventBreakerRulesetRules.timestampEarliest) &&
        Objects.equals(this.timestampLatest, eventBreakerRulesetRules.timestampLatest) &&
        Objects.equals(this.maxEventBytes, eventBreakerRulesetRules.maxEventBytes) &&
        Objects.equals(this.fields, eventBreakerRulesetRules.fields) &&
        Objects.equals(this.disabled, eventBreakerRulesetRules.disabled);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, condition, type, timestampAnchorRegex, timestamp, timestampTimezone, timestampEarliest, timestampLatest, maxEventBytes, fields, disabled);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EventBreakerRulesetRules {\n");
    
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    condition: ").append(toIndentedString(condition)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    timestampAnchorRegex: ").append(toIndentedString(timestampAnchorRegex)).append("\n");
    sb.append("    timestamp: ").append(toIndentedString(timestamp)).append("\n");
    sb.append("    timestampTimezone: ").append(toIndentedString(timestampTimezone)).append("\n");
    sb.append("    timestampEarliest: ").append(toIndentedString(timestampEarliest)).append("\n");
    sb.append("    timestampLatest: ").append(toIndentedString(timestampLatest)).append("\n");
    sb.append("    maxEventBytes: ").append(toIndentedString(maxEventBytes)).append("\n");
    sb.append("    fields: ").append(toIndentedString(fields)).append("\n");
    sb.append("    disabled: ").append(toIndentedString(disabled)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
