/*
 * Cribl LogStream
 * REST API Reference of available endpoints and their supported operations for accessing, updating, creating, or deleting resources. Product documentation available at [docs.cribl.io](http://docs.cribl.io).
 *
 * OpenAPI spec version: 3.1.2-abb571bc
 * Contact: support@cribl.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.cribl.openapi.dto;

import java.util.Objects;
import java.util.Arrays;
import com.cribl.openapi.dto.Authentication;
import com.cribl.openapi.dto.InputSplunkContentConfig;
import com.cribl.openapi.dto.InputSplunkLokiAuth;
import com.cribl.openapi.dto.InputSplunkPrometheusAuth;
import com.cribl.openapi.dto.InputSplunkSamples;
import com.cribl.openapi.dto.KafkaSchemaRegistryAuthentication;
import com.cribl.openapi.dto.NotificationMetadata;
import com.cribl.openapi.dto.SavedJobCollectionInputPreprocess;
import com.cribl.openapi.dto.TLSSettingsServerSide;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
/**
 * InputS3
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2021-10-08T00:23:34.796-04:00[America/New_York]")
public class InputS3 implements OneOfInput, AnyOfInputS3 {
  @SerializedName("id")
  private String id = null;

  /**
   * Gets or Sets type
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    GOOGLE_PUBSUB("google_pubsub"),
    SPLUNK_HEC("splunk_hec"),
    SYSLOG("syslog"),
    TCPJSON("tcpjson"),
    GRAFANA("grafana"),
    LOKI("loki"),
    HTTP("http"),
    HTTP_RAW("http_raw"),
    FIREHOSE("firehose"),
    ELASTIC("elastic"),
    KAFKA("kafka"),
    KINESIS("kinesis"),
    EVENTHUB("eventhub"),
    AZURE_BLOB("azure_blob"),
    METRICS("metrics"),
    SQS("sqs"),
    S3("s3"),
    SNMP("snmp"),
    TCP("tcp"),
    OFFICE365_SERVICE("office365_service"),
    OFFICE365_MGMT("office365_mgmt"),
    OFFICE365_MSG_TRACE("office365_msg_trace"),
    PROMETHEUS("prometheus"),
    PROMETHEUS_RW("prometheus_rw"),
    DATAGEN("datagen"),
    APPSCOPE("appscope"),
    GOOGLE_PUBSUB_26("google_pubsub"),
    CRIBL("cribl"),
    CRIBLMETRICS("criblmetrics");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TypeEnum fromValue(String text) {
      for (TypeEnum b : TypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return TypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("type")
  private TypeEnum type = collection;

  @SerializedName("disabled")
  private Boolean disabled = false;

  @SerializedName("pipeline")
  private String pipeline = null;

  @SerializedName("host")
  private String host = "0.0.0.0";

  @SerializedName("port")
  private BigDecimal port = new BigDecimal(162);

  @SerializedName("tls")
  private TLSSettingsServerSide tls = null;

  @SerializedName("ipWhitelistRegex")
  private String ipWhitelistRegex = "/.*_/";

  @SerializedName("maxActiveCxn")
  private BigDecimal maxActiveCxn = new BigDecimal(1000);

  @SerializedName("enableProxyHeader")
  private Boolean enableProxyHeader = false;

  @SerializedName("metadata")
  private List<NotificationMetadata> metadata = null;

  @SerializedName("breakerRulesets")
  private List<String> breakerRulesets = null;

  @SerializedName("staleChannelFlushMs")
  private BigDecimal staleChannelFlushMs = new BigDecimal(10000);

  @SerializedName("authTokens")
  private List<String> authTokens = null;

  @SerializedName("maxActiveReq")
  private BigDecimal maxActiveReq = new BigDecimal(256);

  @SerializedName("activityLogSampleRate")
  private BigDecimal activityLogSampleRate = new BigDecimal(100);

  @SerializedName("elasticAPI")
  private String elasticAPI = "/elastic";

  @SerializedName("splunkHecAPI")
  private String splunkHecAPI = "/services/collector";

  @SerializedName("allowedIndexes")
  private List<String> allowedIndexes = null;

  @SerializedName("splunkHecAcks")
  private Boolean splunkHecAcks = false;

  @SerializedName("udpPort")
  private BigDecimal udpPort = null;

  @SerializedName("tcpPort")
  private BigDecimal tcpPort = null;

  @SerializedName("maxBufferSize")
  private BigDecimal maxBufferSize = new BigDecimal(1000);

  @SerializedName("timestampTimezone")
  private String timestampTimezone = "local";

  @SerializedName("singleMsgUdpPackets")
  private Boolean singleMsgUdpPackets = false;

  @SerializedName("keepFieldsList")
  private List<String> keepFieldsList = null;

  /**
   * Enter a token directly, or provide a secret referencing a token
   */
  @JsonAdapter(AuthTypeEnum.Adapter.class)
  public enum AuthTypeEnum {
    MANUAL("manual"),
    SECRET("secret"),
    CREDENTIALSSECRET("credentialsSecret"),
    TOKEN("token"),
    TEXTSECRET("textSecret");

    private String value;

    AuthTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static AuthTypeEnum fromValue(String text) {
      for (AuthTypeEnum b : AuthTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<AuthTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AuthTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AuthTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return AuthTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("authType")
  private AuthTypeEnum authType = AuthTypeEnum.MANUAL;

  @SerializedName("criblAPI")
  private String criblAPI = "/cribl";

  @SerializedName("allowedPaths")
  private List<String> allowedPaths = null;

  @SerializedName("allowedMethods")
  private List<String> allowedMethods = null;

  @SerializedName("brokers")
  private List<String> brokers = null;

  @SerializedName("topics")
  private List<String> topics = null;

  @SerializedName("groupId")
  private String groupId = "Cribl";

  @SerializedName("fromBeginning")
  private Boolean fromBeginning = true;

  @SerializedName("kafkaSchemaRegistry")
  private KafkaSchemaRegistryAuthentication kafkaSchemaRegistry = null;

  @SerializedName("sasl")
  private Authentication sasl = null;

  @SerializedName("sessionTimeout")
  private BigDecimal sessionTimeout = new BigDecimal(30000);

  @SerializedName("rebalanceTimeout")
  private BigDecimal rebalanceTimeout = new BigDecimal(60000);

  @SerializedName("heartbeatInterval")
  private BigDecimal heartbeatInterval = new BigDecimal(3000);

  @SerializedName("streamName")
  private String streamName = null;

  @SerializedName("serviceInterval")
  private BigDecimal serviceInterval = new BigDecimal(1);

  @SerializedName("shardExpr")
  private String shardExpr = "true";

  /**
   * Location where to start reading a shard for the first time.
   */
  @JsonAdapter(ShardIteratorTypeEnum.Adapter.class)
  public enum ShardIteratorTypeEnum {
    TRIM_HORIZON("TRIM_HORIZON"),
    LATEST("LATEST");

    private String value;

    ShardIteratorTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ShardIteratorTypeEnum fromValue(String text) {
      for (ShardIteratorTypeEnum b : ShardIteratorTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ShardIteratorTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ShardIteratorTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ShardIteratorTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return ShardIteratorTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("shardIteratorType")
  private ShardIteratorTypeEnum shardIteratorType = ShardIteratorTypeEnum.TRIM_HORIZON;

  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  @JsonAdapter(PayloadFormatEnum.Adapter.class)
  public enum PayloadFormatEnum {
    CRIBL("cribl"),
    NDJSON("ndjson"),
    CLOUDWATCH("cloudwatch"),
    LINE("line");

    private String value;

    PayloadFormatEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static PayloadFormatEnum fromValue(String text) {
      for (PayloadFormatEnum b : PayloadFormatEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<PayloadFormatEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PayloadFormatEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PayloadFormatEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return PayloadFormatEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("payloadFormat")
  private PayloadFormatEnum payloadFormat = PayloadFormatEnum.CRIBL;

  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  @JsonAdapter(AwsAuthenticationMethodEnum.Adapter.class)
  public enum AwsAuthenticationMethodEnum {
    AUTO("auto"),
    MANUAL("manual"),
    SECRET("secret");

    private String value;

    AwsAuthenticationMethodEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static AwsAuthenticationMethodEnum fromValue(String text) {
      for (AwsAuthenticationMethodEnum b : AwsAuthenticationMethodEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<AwsAuthenticationMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AwsAuthenticationMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AwsAuthenticationMethodEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return AwsAuthenticationMethodEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("awsAuthenticationMethod")
  private AwsAuthenticationMethodEnum awsAuthenticationMethod = AwsAuthenticationMethodEnum.AUTO;

  @SerializedName("awsSecretKey")
  private String awsSecretKey = null;

  /**
   * Region to retrieve messages from. Select &#x27;default&#x27; to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
   */
  @JsonAdapter(RegionEnum.Adapter.class)
  public enum RegionEnum {
    PUBSUB_GOOGLEAPIS_COM("pubsub.googleapis.com"),
    US_EAST1_PUBSUB_GOOGLEAPIS_COM("us-east1-pubsub.googleapis.com"),
    US_EAST4_PUBSUB_GOOGLEAPIS_COM("us-east4-pubsub.googleapis.com"),
    US_CENTRAL1_PUBSUB_GOOGLEAPIS_COM("us-central1-pubsub.googleapis.com"),
    US_CENTRAL2_PUBSUB_GOOGLEAPIS_COM("us-central2-pubsub.googleapis.com"),
    US_WEST1_PUBSUB_GOOGLEAPIS_COM("us-west1-pubsub.googleapis.com"),
    US_WEST2_PUBSUB_GOOGLEAPIS_COM("us-west2-pubsub.googleapis.com"),
    US_WEST3_PUBSUB_GOOGLEAPIS_COM("us-west3-pubsub.googleapis.com"),
    SOUTHAMERICA_EAST1_PUBSUB_GOOGLEAPIS_COM("southamerica-east1-pubsub.googleapis.com"),
    NORTHAMERICA_NORTHEAST1_PUBSUB_GOOGLEAPIS_COM("northamerica-northeast1-pubsub.googleapis.com"),
    EUROPE_WEST6_PUBSUB_GOOGLEAPIS_COM("europe-west6-pubsub.googleapis.com"),
    EUROPE_WEST4_PUBSUB_GOOGLEAPIS_COM("europe-west4-pubsub.googleapis.com"),
    EUROPE_WEST3_PUBSUB_GOOGLEAPIS_COM("europe-west3-pubsub.googleapis.com"),
    EUROPE_WEST2_PUBSUB_GOOGLEAPIS_COM("europe-west2-pubsub.googleapis.com"),
    EUROPE_WEST1_PUBSUB_GOOGLEAPIS_COM("europe-west1-pubsub.googleapis.com"),
    EUROPE_NORTH1_PUBSUB_GOOGLEAPIS_COM("europe-north1-pubsub.googleapis.com"),
    AUSTRALIA_SOUTHEAST1_PUBSUB_GOOGLEAPIS_COM("australia-southeast1-pubsub.googleapis.com"),
    ASIA_SOUTHEAST1_PUBSUB_GOOGLEAPIS_COM("asia-southeast1-pubsub.googleapis.com"),
    ASIA_SOUTH1_PUBSUB_GOOGLEAPIS_COM("asia-south1-pubsub.googleapis.com"),
    ASIA_NORTHEAST3_PUBSUB_GOOGLEAPIS_COM("asia-northeast3-pubsub.googleapis.com"),
    ASIA_NORTHEAST2_PUBSUB_GOOGLEAPIS_COM("asia-northeast2-pubsub.googleapis.com"),
    ASIA_NORTHEAST1_PUBSUB_GOOGLEAPIS_COM("asia-northeast1-pubsub.googleapis.com"),
    ASIA_EAST2_PUBSUB_GOOGLEAPIS_COM("asia-east2-pubsub.googleapis.com"),
    ASIA_EAST1_PUBSUB_GOOGLEAPIS_COM("asia-east1-pubsub.googleapis.com");

    private String value;

    RegionEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static RegionEnum fromValue(String text) {
      for (RegionEnum b : RegionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<RegionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RegionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RegionEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return RegionEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("region")
  private RegionEnum region = null;

  @SerializedName("endpoint")
  private String endpoint = null;

  /**
   * Signature version to use for signing S3 requests.
   */
  @JsonAdapter(SignatureVersionEnum.Adapter.class)
  public enum SignatureVersionEnum {
    V2("v2"),
    V4("v4");

    private String value;

    SignatureVersionEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static SignatureVersionEnum fromValue(String text) {
      for (SignatureVersionEnum b : SignatureVersionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<SignatureVersionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SignatureVersionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SignatureVersionEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return SignatureVersionEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("signatureVersion")
  private SignatureVersionEnum signatureVersion = SignatureVersionEnum.V4;

  @SerializedName("reuseConnections")
  private Boolean reuseConnections = true;

  @SerializedName("rejectUnauthorized")
  private Boolean rejectUnauthorized = true;

  @SerializedName("enableAssumeRole")
  private Boolean enableAssumeRole = true;

  @SerializedName("assumeRoleArn")
  private String assumeRoleArn = null;

  @SerializedName("assumeRoleExternalId")
  private String assumeRoleExternalId = null;

  @SerializedName("verifyKPLCheckSums")
  private Boolean verifyKPLCheckSums = false;

  @SerializedName("queueName")
  private String queueName = null;

  @SerializedName("fileFilter")
  private String fileFilter = "/.*_/";

  @SerializedName("visibilityTimeout")
  private BigDecimal visibilityTimeout = new BigDecimal(600);

  @SerializedName("numReceivers")
  private BigDecimal numReceivers = new BigDecimal(1);

  @SerializedName("maxMessages")
  private BigDecimal maxMessages = new BigDecimal(1);

  @SerializedName("servicePeriodSecs")
  private BigDecimal servicePeriodSecs = new BigDecimal(5);

  @SerializedName("skipOnError")
  private Boolean skipOnError = false;

  @SerializedName("prefix")
  private String prefix = "cribl.logstream.";

  /**
   * The queue type used (or created). Defaults to Standard
   */
  @JsonAdapter(QueueTypeEnum.Adapter.class)
  public enum QueueTypeEnum {
    STANDARD("standard"),
    FIFO("fifo");

    private String value;

    QueueTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static QueueTypeEnum fromValue(String text) {
      for (QueueTypeEnum b : QueueTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<QueueTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final QueueTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public QueueTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return QueueTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("queueType")
  private QueueTypeEnum queueType = QueueTypeEnum.STANDARD;

  @SerializedName("awsAccountId")
  private String awsAccountId = null;

  @SerializedName("createQueue")
  private Boolean createQueue = false;

  @SerializedName("samples")
  private List<InputSplunkSamples> samples = null;

  @SerializedName("socketTimeout")
  private BigDecimal socketTimeout = new BigDecimal(300);

  @SerializedName("enableSQSAssumeRole")
  private Boolean enableSQSAssumeRole = false;

  @SerializedName("preprocess")
  private SavedJobCollectionInputPreprocess preprocess = null;

  @SerializedName("enableHeader")
  private Boolean enableHeader = false;

  @SerializedName("sendToRoutes")
  private Boolean sendToRoutes = true;

  @SerializedName("throttleRatePerSec")
  private String throttleRatePerSec = "0";

  @SerializedName("tenantId")
  private String tenantId = null;

  @SerializedName("appId")
  private String appId = null;

  @SerializedName("timeout")
  private BigDecimal timeout = new BigDecimal(600);

  @SerializedName("keepAliveTime")
  private BigDecimal keepAliveTime = new BigDecimal(60);

  @SerializedName("maxMissedKeepAlives")
  private BigDecimal maxMissedKeepAlives = new BigDecimal(3);

  @SerializedName("contentConfig")
  private List<InputSplunkContentConfig> contentConfig = null;

  /**
   * Office 365 subscription plan for your organization, typically Enterprise
   */
  @JsonAdapter(PlanTypeEnum.Adapter.class)
  public enum PlanTypeEnum {
    ENTERPRISE_GCC("enterprise_gcc"),
    GCC("gcc"),
    GCC_HIGH("gcc_high"),
    DOD("dod");

    private String value;

    PlanTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static PlanTypeEnum fromValue(String text) {
      for (PlanTypeEnum b : PlanTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<PlanTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PlanTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PlanTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return PlanTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("planType")
  private PlanTypeEnum planType = PlanTypeEnum.ENTERPRISE_GCC;

  @SerializedName("publisherIdentifier")
  private String publisherIdentifier = null;

  @SerializedName("url")
  private String url = "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace";

  @SerializedName("interval")
  private BigDecimal interval = new BigDecimal(15);

  @SerializedName("startDate")
  private String startDate = null;

  @SerializedName("endDate")
  private String endDate = null;

  /**
   * Collector runtime Log Level
   */
  @JsonAdapter(LogLevelEnum.Adapter.class)
  public enum LogLevelEnum {
    ERROR("error"),
    WARN("warn"),
    INFO("info"),
    DEBUG("debug");

    private String value;

    LogLevelEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static LogLevelEnum fromValue(String text) {
      for (LogLevelEnum b : LogLevelEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<LogLevelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LogLevelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LogLevelEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return LogLevelEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("logLevel")
  private LogLevelEnum logLevel = LogLevelEnum.INFO;

  @SerializedName("disableTimeFilter")
  private Boolean disableTimeFilter = true;

  @SerializedName("dimensionList")
  private List<String> dimensionList = null;

  /**
   * Target discovery mechanism, use static to manually enter a list of targets
   */
  @JsonAdapter(DiscoveryTypeEnum.Adapter.class)
  public enum DiscoveryTypeEnum {
    STATIC("static"),
    DNS("dns"),
    EC2("ec2");

    private String value;

    DiscoveryTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static DiscoveryTypeEnum fromValue(String text) {
      for (DiscoveryTypeEnum b : DiscoveryTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<DiscoveryTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DiscoveryTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DiscoveryTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return DiscoveryTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("discoveryType")
  private DiscoveryTypeEnum discoveryType = DiscoveryTypeEnum.STATIC;

  @SerializedName("prometheusAPI")
  private String prometheusAPI = "/api/prom/push";

  @SerializedName("keepAliveTimeout")
  private BigDecimal keepAliveTimeout = new BigDecimal(5);

  @SerializedName("lokiAPI")
  private String lokiAPI = "/loki/api/v1/push";

  @SerializedName("prometheusAuth")
  private InputSplunkPrometheusAuth prometheusAuth = null;

  @SerializedName("lokiAuth")
  private InputSplunkLokiAuth lokiAuth = null;

  @SerializedName("topicName")
  private String topicName = null;

  @SerializedName("subscriptionName")
  private String subscriptionName = null;

  @SerializedName("createTopic")
  private Boolean createTopic = false;

  @SerializedName("createSubscription")
  private Boolean createSubscription = true;

  /**
   * Google authentication method. Choose Auto to use environment variables PUBSUB_PROJECT and PUBSUB_CREDENTIALS.
   */
  @JsonAdapter(GoogleAuthMethodEnum.Adapter.class)
  public enum GoogleAuthMethodEnum {
    AUTO("auto"),
    MANUAL("manual"),
    SECRET("secret");

    private String value;

    GoogleAuthMethodEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static GoogleAuthMethodEnum fromValue(String text) {
      for (GoogleAuthMethodEnum b : GoogleAuthMethodEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<GoogleAuthMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final GoogleAuthMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public GoogleAuthMethodEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return GoogleAuthMethodEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("googleAuthMethod")
  private GoogleAuthMethodEnum googleAuthMethod = GoogleAuthMethodEnum.MANUAL;

  @SerializedName("serviceAccountCredentials")
  private Object serviceAccountCredentials = null;

  @SerializedName("secret")
  private Object secret = null;

  @SerializedName("maxBacklog")
  private BigDecimal maxBacklog = new BigDecimal(10);

  @SerializedName("requestTimeout")
  private BigDecimal requestTimeout = new BigDecimal(60000);

  public InputS3 id(String id) {
    this.id = id;
    return this;
  }

   /**
   * Unique ID for this input
   * @return id
  **/
  @Schema(description = "Unique ID for this input")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public InputS3 type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * Get type
   * @return type
  **/
  @Schema(description = "")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public InputS3 disabled(Boolean disabled) {
    this.disabled = disabled;
    return this;
  }

   /**
   * Enable/disable this input
   * @return disabled
  **/
  @Schema(description = "Enable/disable this input")
  public Boolean isDisabled() {
    return disabled;
  }

  public void setDisabled(Boolean disabled) {
    this.disabled = disabled;
  }

  public InputS3 pipeline(String pipeline) {
    this.pipeline = pipeline;
    return this;
  }

   /**
   * Pipeline to process data from this Source before sending it through the Routes.
   * @return pipeline
  **/
  @Schema(description = "Pipeline to process data from this Source before sending it through the Routes.")
  public String getPipeline() {
    return pipeline;
  }

  public void setPipeline(String pipeline) {
    this.pipeline = pipeline;
  }

  public InputS3 host(String host) {
    this.host = host;
    return this;
  }

   /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   * @return host
  **/
  @Schema(description = "Address to bind on. Defaults to 0.0.0.0 (all addresses).")
  public String getHost() {
    return host;
  }

  public void setHost(String host) {
    this.host = host;
  }

  public InputS3 port(BigDecimal port) {
    this.port = port;
    return this;
  }

   /**
   * Port to listen to.
   * maximum: 65535
   * @return port
  **/
  @Schema(description = "Port to listen to.")
  public BigDecimal getPort() {
    return port;
  }

  public void setPort(BigDecimal port) {
    this.port = port;
  }

  public InputS3 tls(TLSSettingsServerSide tls) {
    this.tls = tls;
    return this;
  }

   /**
   * Get tls
   * @return tls
  **/
  @Schema(description = "")
  public TLSSettingsServerSide getTls() {
    return tls;
  }

  public void setTls(TLSSettingsServerSide tls) {
    this.tls = tls;
  }

  public InputS3 ipWhitelistRegex(String ipWhitelistRegex) {
    this.ipWhitelistRegex = ipWhitelistRegex;
    return this;
  }

   /**
   * Regex matching IP addresses that are allowed to establish a connection.
   * @return ipWhitelistRegex
  **/
  @Schema(description = "Regex matching IP addresses that are allowed to establish a connection.")
  public String getIpWhitelistRegex() {
    return ipWhitelistRegex;
  }

  public void setIpWhitelistRegex(String ipWhitelistRegex) {
    this.ipWhitelistRegex = ipWhitelistRegex;
  }

  public InputS3 maxActiveCxn(BigDecimal maxActiveCxn) {
    this.maxActiveCxn = maxActiveCxn;
    return this;
  }

   /**
   * Maximum number of active connections allowed per worker process, use 0 for unlimited
   * minimum: 0
   * @return maxActiveCxn
  **/
  @Schema(description = "Maximum number of active connections allowed per worker process, use 0 for unlimited")
  public BigDecimal getMaxActiveCxn() {
    return maxActiveCxn;
  }

  public void setMaxActiveCxn(BigDecimal maxActiveCxn) {
    this.maxActiveCxn = maxActiveCxn;
  }

  public InputS3 enableProxyHeader(Boolean enableProxyHeader) {
    this.enableProxyHeader = enableProxyHeader;
    return this;
  }

   /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2.
   * @return enableProxyHeader
  **/
  @Schema(description = "Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2.")
  public Boolean isEnableProxyHeader() {
    return enableProxyHeader;
  }

  public void setEnableProxyHeader(Boolean enableProxyHeader) {
    this.enableProxyHeader = enableProxyHeader;
  }

  public InputS3 metadata(List<NotificationMetadata> metadata) {
    this.metadata = metadata;
    return this;
  }

  public InputS3 addMetadataItem(NotificationMetadata metadataItem) {
    if (this.metadata == null) {
      this.metadata = new ArrayList<>();
    }
    this.metadata.add(metadataItem);
    return this;
  }

   /**
   * Fields to add.
   * @return metadata
  **/
  @Schema(description = "Fields to add.")
  public List<NotificationMetadata> getMetadata() {
    return metadata;
  }

  public void setMetadata(List<NotificationMetadata> metadata) {
    this.metadata = metadata;
  }

  public InputS3 breakerRulesets(List<String> breakerRulesets) {
    this.breakerRulesets = breakerRulesets;
    return this;
  }

  public InputS3 addBreakerRulesetsItem(String breakerRulesetsItem) {
    if (this.breakerRulesets == null) {
      this.breakerRulesets = new ArrayList<>();
    }
    this.breakerRulesets.add(breakerRulesetsItem);
    return this;
  }

   /**
   * A list of event breaking rulesets that will be applied, in order, to the input data stream.
   * @return breakerRulesets
  **/
  @Schema(description = "A list of event breaking rulesets that will be applied, in order, to the input data stream.")
  public List<String> getBreakerRulesets() {
    return breakerRulesets;
  }

  public void setBreakerRulesets(List<String> breakerRulesets) {
    this.breakerRulesets = breakerRulesets;
  }

  public InputS3 staleChannelFlushMs(BigDecimal staleChannelFlushMs) {
    this.staleChannelFlushMs = staleChannelFlushMs;
    return this;
  }

   /**
   * The amount of time (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel, before flushing the data stream out, as-is, to the Pipelines.
   * minimum: 10
   * maximum: 600000
   * @return staleChannelFlushMs
  **/
  @Schema(description = "The amount of time (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel, before flushing the data stream out, as-is, to the Pipelines.")
  public BigDecimal getStaleChannelFlushMs() {
    return staleChannelFlushMs;
  }

  public void setStaleChannelFlushMs(BigDecimal staleChannelFlushMs) {
    this.staleChannelFlushMs = staleChannelFlushMs;
  }

  public InputS3 authTokens(List<String> authTokens) {
    this.authTokens = authTokens;
    return this;
  }

  public InputS3 addAuthTokensItem(String authTokensItem) {
    if (this.authTokens == null) {
      this.authTokens = new ArrayList<>();
    }
    this.authTokens.add(authTokensItem);
    return this;
  }

   /**
   * Shared secrets to be provided by any client (Authorization: &lt;token&gt;). If empty, unauthed access is permitted.
   * @return authTokens
  **/
  @Schema(description = "Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthed access is permitted.")
  public List<String> getAuthTokens() {
    return authTokens;
  }

  public void setAuthTokens(List<String> authTokens) {
    this.authTokens = authTokens;
  }

  public InputS3 maxActiveReq(BigDecimal maxActiveReq) {
    this.maxActiveReq = maxActiveReq;
    return this;
  }

   /**
   * Maximum number of active requests allowed for this source, per worker process. Use 0 for unlimited.
   * minimum: 0
   * @return maxActiveReq
  **/
  @Schema(description = "Maximum number of active requests allowed for this source, per worker process. Use 0 for unlimited.")
  public BigDecimal getMaxActiveReq() {
    return maxActiveReq;
  }

  public void setMaxActiveReq(BigDecimal maxActiveReq) {
    this.maxActiveReq = maxActiveReq;
  }

  public InputS3 activityLogSampleRate(BigDecimal activityLogSampleRate) {
    this.activityLogSampleRate = activityLogSampleRate;
    return this;
  }

   /**
   * How often request activity is logged at the &#x60;info&#x60; level. A value of 1 would log every request, 10 every 10th request, etc.
   * minimum: 1
   * @return activityLogSampleRate
  **/
  @Schema(description = "How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.")
  public BigDecimal getActivityLogSampleRate() {
    return activityLogSampleRate;
  }

  public void setActivityLogSampleRate(BigDecimal activityLogSampleRate) {
    this.activityLogSampleRate = activityLogSampleRate;
  }

  public InputS3 elasticAPI(String elasticAPI) {
    this.elasticAPI = elasticAPI;
    return this;
  }

   /**
   * Absolute path where to listen for the Elasticsearch API requests. At the moment only _bulk (default /elastic/_bulk) is available. Use empty string to disable
   * @return elasticAPI
  **/
  @Schema(description = "Absolute path where to listen for the Elasticsearch API requests. At the moment only _bulk (default /elastic/_bulk) is available. Use empty string to disable")
  public String getElasticAPI() {
    return elasticAPI;
  }

  public void setElasticAPI(String elasticAPI) {
    this.elasticAPI = elasticAPI;
  }

  public InputS3 splunkHecAPI(String splunkHecAPI) {
    this.splunkHecAPI = splunkHecAPI;
    return this;
  }

   /**
   * Absolute path where to listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
   * @return splunkHecAPI
  **/
  @Schema(description = "Absolute path where to listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.")
  public String getSplunkHecAPI() {
    return splunkHecAPI;
  }

  public void setSplunkHecAPI(String splunkHecAPI) {
    this.splunkHecAPI = splunkHecAPI;
  }

  public InputS3 allowedIndexes(List<String> allowedIndexes) {
    this.allowedIndexes = allowedIndexes;
    return this;
  }

  public InputS3 addAllowedIndexesItem(String allowedIndexesItem) {
    if (this.allowedIndexes == null) {
      this.allowedIndexes = new ArrayList<>();
    }
    this.allowedIndexes.add(allowedIndexesItem);
    return this;
  }

   /**
   * List values allowed in HEC event index field, allows wildcards. Leave blank to skip validation.
   * @return allowedIndexes
  **/
  @Schema(description = "List values allowed in HEC event index field, allows wildcards. Leave blank to skip validation.")
  public List<String> getAllowedIndexes() {
    return allowedIndexes;
  }

  public void setAllowedIndexes(List<String> allowedIndexes) {
    this.allowedIndexes = allowedIndexes;
  }

  public InputS3 splunkHecAcks(Boolean splunkHecAcks) {
    this.splunkHecAcks = splunkHecAcks;
    return this;
  }

   /**
   * Whether to enable Splunk HEC acknowledgements
   * @return splunkHecAcks
  **/
  @Schema(description = "Whether to enable Splunk HEC acknowledgements")
  public Boolean isSplunkHecAcks() {
    return splunkHecAcks;
  }

  public void setSplunkHecAcks(Boolean splunkHecAcks) {
    this.splunkHecAcks = splunkHecAcks;
  }

  public InputS3 udpPort(BigDecimal udpPort) {
    this.udpPort = udpPort;
    return this;
  }

   /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   * maximum: 65535
   * @return udpPort
  **/
  @Schema(description = "Enter UDP port number to listen on. Not required if listening on TCP.")
  public BigDecimal getUdpPort() {
    return udpPort;
  }

  public void setUdpPort(BigDecimal udpPort) {
    this.udpPort = udpPort;
  }

  public InputS3 tcpPort(BigDecimal tcpPort) {
    this.tcpPort = tcpPort;
    return this;
  }

   /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   * maximum: 65535
   * @return tcpPort
  **/
  @Schema(description = "Enter TCP port number to listen on. Not required if listening on UDP.")
  public BigDecimal getTcpPort() {
    return tcpPort;
  }

  public void setTcpPort(BigDecimal tcpPort) {
    this.tcpPort = tcpPort;
  }

  public InputS3 maxBufferSize(BigDecimal maxBufferSize) {
    this.maxBufferSize = maxBufferSize;
    return this;
  }

   /**
   * Maximum number of events to buffer when downstream is blocking.
   * minimum: 0
   * @return maxBufferSize
  **/
  @Schema(description = "Maximum number of events to buffer when downstream is blocking.")
  public BigDecimal getMaxBufferSize() {
    return maxBufferSize;
  }

  public void setMaxBufferSize(BigDecimal maxBufferSize) {
    this.maxBufferSize = maxBufferSize;
  }

  public InputS3 timestampTimezone(String timestampTimezone) {
    this.timestampTimezone = timestampTimezone;
    return this;
  }

   /**
   * Timezone to assign to timestamps without timezone info.
   * @return timestampTimezone
  **/
  @Schema(description = "Timezone to assign to timestamps without timezone info.")
  public String getTimestampTimezone() {
    return timestampTimezone;
  }

  public void setTimestampTimezone(String timestampTimezone) {
    this.timestampTimezone = timestampTimezone;
  }

  public InputS3 singleMsgUdpPackets(Boolean singleMsgUdpPackets) {
    this.singleMsgUdpPackets = singleMsgUdpPackets;
    return this;
  }

   /**
   * Whether to treat UDP packet data received as full syslog message
   * @return singleMsgUdpPackets
  **/
  @Schema(description = "Whether to treat UDP packet data received as full syslog message")
  public Boolean isSingleMsgUdpPackets() {
    return singleMsgUdpPackets;
  }

  public void setSingleMsgUdpPackets(Boolean singleMsgUdpPackets) {
    this.singleMsgUdpPackets = singleMsgUdpPackets;
  }

  public InputS3 keepFieldsList(List<String> keepFieldsList) {
    this.keepFieldsList = keepFieldsList;
    return this;
  }

  public InputS3 addKeepFieldsListItem(String keepFieldsListItem) {
    if (this.keepFieldsList == null) {
      this.keepFieldsList = new ArrayList<>();
    }
    this.keepFieldsList.add(keepFieldsListItem);
    return this;
  }

   /**
   * Wildcard list of fields to keep from source data, * &#x3D; ALL (default)
   * @return keepFieldsList
  **/
  @Schema(description = "Wildcard list of fields to keep from source data, * = ALL (default)")
  public List<String> getKeepFieldsList() {
    return keepFieldsList;
  }

  public void setKeepFieldsList(List<String> keepFieldsList) {
    this.keepFieldsList = keepFieldsList;
  }

  public InputS3 authType(AuthTypeEnum authType) {
    this.authType = authType;
    return this;
  }

   /**
   * Enter a token directly, or provide a secret referencing a token
   * @return authType
  **/
  @Schema(description = "Enter a token directly, or provide a secret referencing a token")
  public AuthTypeEnum getAuthType() {
    return authType;
  }

  public void setAuthType(AuthTypeEnum authType) {
    this.authType = authType;
  }

  public InputS3 criblAPI(String criblAPI) {
    this.criblAPI = criblAPI;
    return this;
  }

   /**
   * Absolute path where to listen for the Cribl HTTP API requests. At the moment only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
   * @return criblAPI
  **/
  @Schema(description = "Absolute path where to listen for the Cribl HTTP API requests. At the moment only _bulk (default /cribl/_bulk) is available. Use empty string to disable.")
  public String getCriblAPI() {
    return criblAPI;
  }

  public void setCriblAPI(String criblAPI) {
    this.criblAPI = criblAPI;
  }

  public InputS3 allowedPaths(List<String> allowedPaths) {
    this.allowedPaths = allowedPaths;
    return this;
  }

  public InputS3 addAllowedPathsItem(String allowedPathsItem) {
    if (this.allowedPaths == null) {
      this.allowedPaths = new ArrayList<>();
    }
    this.allowedPaths.add(allowedPathsItem);
    return this;
  }

   /**
   * List of URI paths accepted by this input, wildcards are supported, e.g /api/v*_/hook. Defaults to allow all.
   * @return allowedPaths
  **/
  @Schema(description = "List of URI paths accepted by this input, wildcards are supported, e.g /api/v*_/hook. Defaults to allow all.")
  public List<String> getAllowedPaths() {
    return allowedPaths;
  }

  public void setAllowedPaths(List<String> allowedPaths) {
    this.allowedPaths = allowedPaths;
  }

  public InputS3 allowedMethods(List<String> allowedMethods) {
    this.allowedMethods = allowedMethods;
    return this;
  }

  public InputS3 addAllowedMethodsItem(String allowedMethodsItem) {
    if (this.allowedMethods == null) {
      this.allowedMethods = new ArrayList<>();
    }
    this.allowedMethods.add(allowedMethodsItem);
    return this;
  }

   /**
   * List of HTTP methods accepted by this input, wildcards are supported, e.g. P*, GET. Defaults to allow all.
   * @return allowedMethods
  **/
  @Schema(description = "List of HTTP methods accepted by this input, wildcards are supported, e.g. P*, GET. Defaults to allow all.")
  public List<String> getAllowedMethods() {
    return allowedMethods;
  }

  public void setAllowedMethods(List<String> allowedMethods) {
    this.allowedMethods = allowedMethods;
  }

  public InputS3 brokers(List<String> brokers) {
    this.brokers = brokers;
    return this;
  }

  public InputS3 addBrokersItem(String brokersItem) {
    if (this.brokers == null) {
      this.brokers = new ArrayList<>();
    }
    this.brokers.add(brokersItem);
    return this;
  }

   /**
   * List of Event Hubs Kafka brokers to connect to, e.g., yourdomain.servicebus.windows.net:9093. The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
   * @return brokers
  **/
  @Schema(description = "List of Event Hubs Kafka brokers to connect to, e.g., yourdomain.servicebus.windows.net:9093. The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.")
  public List<String> getBrokers() {
    return brokers;
  }

  public void setBrokers(List<String> brokers) {
    this.brokers = brokers;
  }

  public InputS3 topics(List<String> topics) {
    this.topics = topics;
    return this;
  }

  public InputS3 addTopicsItem(String topicsItem) {
    if (this.topics == null) {
      this.topics = new ArrayList<>();
    }
    this.topics.add(topicsItem);
    return this;
  }

   /**
   * The name of the Event Hub (a.k.a. Kafka Topic) to subscribe to.
   * @return topics
  **/
  @Schema(description = "The name of the Event Hub (a.k.a. Kafka Topic) to subscribe to.")
  public List<String> getTopics() {
    return topics;
  }

  public void setTopics(List<String> topics) {
    this.topics = topics;
  }

  public InputS3 groupId(String groupId) {
    this.groupId = groupId;
    return this;
  }

   /**
   * Specifies the consumer group this instance belongs to, default is &#x27;Cribl&#x27;.
   * @return groupId
  **/
  @Schema(description = "Specifies the consumer group this instance belongs to, default is 'Cribl'.")
  public String getGroupId() {
    return groupId;
  }

  public void setGroupId(String groupId) {
    this.groupId = groupId;
  }

  public InputS3 fromBeginning(Boolean fromBeginning) {
    this.fromBeginning = fromBeginning;
    return this;
  }

   /**
   * Whether to start reading from earliest available data, relevant only during initial subscription.
   * @return fromBeginning
  **/
  @Schema(description = "Whether to start reading from earliest available data, relevant only during initial subscription.")
  public Boolean isFromBeginning() {
    return fromBeginning;
  }

  public void setFromBeginning(Boolean fromBeginning) {
    this.fromBeginning = fromBeginning;
  }

  public InputS3 kafkaSchemaRegistry(KafkaSchemaRegistryAuthentication kafkaSchemaRegistry) {
    this.kafkaSchemaRegistry = kafkaSchemaRegistry;
    return this;
  }

   /**
   * Get kafkaSchemaRegistry
   * @return kafkaSchemaRegistry
  **/
  @Schema(description = "")
  public KafkaSchemaRegistryAuthentication getKafkaSchemaRegistry() {
    return kafkaSchemaRegistry;
  }

  public void setKafkaSchemaRegistry(KafkaSchemaRegistryAuthentication kafkaSchemaRegistry) {
    this.kafkaSchemaRegistry = kafkaSchemaRegistry;
  }

  public InputS3 sasl(Authentication sasl) {
    this.sasl = sasl;
    return this;
  }

   /**
   * Get sasl
   * @return sasl
  **/
  @Schema(description = "")
  public Authentication getSasl() {
    return sasl;
  }

  public void setSasl(Authentication sasl) {
    this.sasl = sasl;
  }

  public InputS3 sessionTimeout(BigDecimal sessionTimeout) {
    this.sessionTimeout = sessionTimeout;
    return this;
  }

   /**
   *        Timeout (a.k.a session.timeout.ms in Kafka domain) used to detect client failures when using Kafka&#x27;s group management facilities.       If the client sends the broker no heartbeats before this timeout expires, the broker will remove this client from the group, and will initiate a rebalance.       Value must be lower than rebalanceTimeout.       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   * minimum: 6000
   * maximum: 300000
   * @return sessionTimeout
  **/
  @Schema(description = "       Timeout (a.k.a session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group management facilities.       If the client sends the broker no heartbeats before this timeout expires, the broker will remove this client from the group, and will initiate a rebalance.       Value must be lower than rebalanceTimeout.       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).")
  public BigDecimal getSessionTimeout() {
    return sessionTimeout;
  }

  public void setSessionTimeout(BigDecimal sessionTimeout) {
    this.sessionTimeout = sessionTimeout;
  }

  public InputS3 rebalanceTimeout(BigDecimal rebalanceTimeout) {
    this.rebalanceTimeout = rebalanceTimeout;
    return this;
  }

   /**
   *        Maximum allowed time (a.k.a rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance has begun.       If the timeout is exceeded, the coordinator broker will remove the worker from the group.       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   * minimum: 1000
   * maximum: 3600000
   * @return rebalanceTimeout
  **/
  @Schema(description = "       Maximum allowed time (a.k.a rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance has begun.       If the timeout is exceeded, the coordinator broker will remove the worker from the group.       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).")
  public BigDecimal getRebalanceTimeout() {
    return rebalanceTimeout;
  }

  public void setRebalanceTimeout(BigDecimal rebalanceTimeout) {
    this.rebalanceTimeout = rebalanceTimeout;
  }

  public InputS3 heartbeatInterval(BigDecimal heartbeatInterval) {
    this.heartbeatInterval = heartbeatInterval;
    return this;
  }

   /**
   *        Expected time (a.k.a heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka&#x27;s group management facilities.       Value must be lower than sessionTimeout, and typically should not exceed 1/3 of the sessionTimeout value.       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   * minimum: 1000
   * maximum: 3600000
   * @return heartbeatInterval
  **/
  @Schema(description = "       Expected time (a.k.a heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group management facilities.       Value must be lower than sessionTimeout, and typically should not exceed 1/3 of the sessionTimeout value.       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).")
  public BigDecimal getHeartbeatInterval() {
    return heartbeatInterval;
  }

  public void setHeartbeatInterval(BigDecimal heartbeatInterval) {
    this.heartbeatInterval = heartbeatInterval;
  }

  public InputS3 streamName(String streamName) {
    this.streamName = streamName;
    return this;
  }

   /**
   * Kinesis stream name to read data from.
   * @return streamName
  **/
  @Schema(description = "Kinesis stream name to read data from.")
  public String getStreamName() {
    return streamName;
  }

  public void setStreamName(String streamName) {
    this.streamName = streamName;
  }

  public InputS3 serviceInterval(BigDecimal serviceInterval) {
    this.serviceInterval = serviceInterval;
    return this;
  }

   /**
   * Time interval in minutes between consecutive service calls
   * minimum: 1
   * maximum: 5
   * @return serviceInterval
  **/
  @Schema(description = "Time interval in minutes between consecutive service calls")
  public BigDecimal getServiceInterval() {
    return serviceInterval;
  }

  public void setServiceInterval(BigDecimal serviceInterval) {
    this.serviceInterval = serviceInterval;
  }

  public InputS3 shardExpr(String shardExpr) {
    this.shardExpr = shardExpr;
    return this;
  }

   /**
   * A JS expression to be called with each shardId for the stream, if the expression evalutates to a truthy value the shard will be processed.
   * @return shardExpr
  **/
  @Schema(description = "A JS expression to be called with each shardId for the stream, if the expression evalutates to a truthy value the shard will be processed.")
  public String getShardExpr() {
    return shardExpr;
  }

  public void setShardExpr(String shardExpr) {
    this.shardExpr = shardExpr;
  }

  public InputS3 shardIteratorType(ShardIteratorTypeEnum shardIteratorType) {
    this.shardIteratorType = shardIteratorType;
    return this;
  }

   /**
   * Location where to start reading a shard for the first time.
   * @return shardIteratorType
  **/
  @Schema(description = "Location where to start reading a shard for the first time.")
  public ShardIteratorTypeEnum getShardIteratorType() {
    return shardIteratorType;
  }

  public void setShardIteratorType(ShardIteratorTypeEnum shardIteratorType) {
    this.shardIteratorType = shardIteratorType;
  }

  public InputS3 payloadFormat(PayloadFormatEnum payloadFormat) {
    this.payloadFormat = payloadFormat;
    return this;
  }

   /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   * @return payloadFormat
  **/
  @Schema(description = "Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.")
  public PayloadFormatEnum getPayloadFormat() {
    return payloadFormat;
  }

  public void setPayloadFormat(PayloadFormatEnum payloadFormat) {
    this.payloadFormat = payloadFormat;
  }

  public InputS3 awsAuthenticationMethod(AwsAuthenticationMethodEnum awsAuthenticationMethod) {
    this.awsAuthenticationMethod = awsAuthenticationMethod;
    return this;
  }

   /**
   * AWS authentication method. Choose Auto to use IAM roles.
   * @return awsAuthenticationMethod
  **/
  @Schema(description = "AWS authentication method. Choose Auto to use IAM roles.")
  public AwsAuthenticationMethodEnum getAwsAuthenticationMethod() {
    return awsAuthenticationMethod;
  }

  public void setAwsAuthenticationMethod(AwsAuthenticationMethodEnum awsAuthenticationMethod) {
    this.awsAuthenticationMethod = awsAuthenticationMethod;
  }

  public InputS3 awsSecretKey(String awsSecretKey) {
    this.awsSecretKey = awsSecretKey;
    return this;
  }

   /**
   * Secret key
   * @return awsSecretKey
  **/
  @Schema(description = "Secret key")
  public String getAwsSecretKey() {
    return awsSecretKey;
  }

  public void setAwsSecretKey(String awsSecretKey) {
    this.awsSecretKey = awsSecretKey;
  }

  public InputS3 region(RegionEnum region) {
    this.region = region;
    return this;
  }

   /**
   * Region to retrieve messages from. Select &#x27;default&#x27; to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
   * @return region
  **/
  @Schema(description = "Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.")
  public RegionEnum getRegion() {
    return region;
  }

  public void setRegion(RegionEnum region) {
    this.region = region;
  }

  public InputS3 endpoint(String endpoint) {
    this.endpoint = endpoint;
    return this;
  }

   /**
   * S3 service endpoint. If empty, defaults to AWS&#x27; Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   * @return endpoint
  **/
  @Schema(description = "S3 service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.")
  public String getEndpoint() {
    return endpoint;
  }

  public void setEndpoint(String endpoint) {
    this.endpoint = endpoint;
  }

  public InputS3 signatureVersion(SignatureVersionEnum signatureVersion) {
    this.signatureVersion = signatureVersion;
    return this;
  }

   /**
   * Signature version to use for signing S3 requests.
   * @return signatureVersion
  **/
  @Schema(description = "Signature version to use for signing S3 requests.")
  public SignatureVersionEnum getSignatureVersion() {
    return signatureVersion;
  }

  public void setSignatureVersion(SignatureVersionEnum signatureVersion) {
    this.signatureVersion = signatureVersion;
  }

  public InputS3 reuseConnections(Boolean reuseConnections) {
    this.reuseConnections = reuseConnections;
    return this;
  }

   /**
   * Whether to reuse connections between requests, which can improve performance.
   * @return reuseConnections
  **/
  @Schema(description = "Whether to reuse connections between requests, which can improve performance.")
  public Boolean isReuseConnections() {
    return reuseConnections;
  }

  public void setReuseConnections(Boolean reuseConnections) {
    this.reuseConnections = reuseConnections;
  }

  public InputS3 rejectUnauthorized(Boolean rejectUnauthorized) {
    this.rejectUnauthorized = rejectUnauthorized;
    return this;
  }

   /**
   * Whether to accept certificates which cannot be verified against a valid CA (e.g. self-signed certificates).
   * @return rejectUnauthorized
  **/
  @Schema(description = "Whether to accept certificates which cannot be verified against a valid CA (e.g. self-signed certificates).")
  public Boolean isRejectUnauthorized() {
    return rejectUnauthorized;
  }

  public void setRejectUnauthorized(Boolean rejectUnauthorized) {
    this.rejectUnauthorized = rejectUnauthorized;
  }

  public InputS3 enableAssumeRole(Boolean enableAssumeRole) {
    this.enableAssumeRole = enableAssumeRole;
    return this;
  }

   /**
   * Use Assume Role credentials to access S3
   * @return enableAssumeRole
  **/
  @Schema(description = "Use Assume Role credentials to access S3")
  public Boolean isEnableAssumeRole() {
    return enableAssumeRole;
  }

  public void setEnableAssumeRole(Boolean enableAssumeRole) {
    this.enableAssumeRole = enableAssumeRole;
  }

  public InputS3 assumeRoleArn(String assumeRoleArn) {
    this.assumeRoleArn = assumeRoleArn;
    return this;
  }

   /**
   * Amazon Resource Name (ARN) of the role to assume
   * @return assumeRoleArn
  **/
  @Schema(description = "Amazon Resource Name (ARN) of the role to assume")
  public String getAssumeRoleArn() {
    return assumeRoleArn;
  }

  public void setAssumeRoleArn(String assumeRoleArn) {
    this.assumeRoleArn = assumeRoleArn;
  }

  public InputS3 assumeRoleExternalId(String assumeRoleExternalId) {
    this.assumeRoleExternalId = assumeRoleExternalId;
    return this;
  }

   /**
   * External ID to use when assuming role
   * @return assumeRoleExternalId
  **/
  @Schema(description = "External ID to use when assuming role")
  public String getAssumeRoleExternalId() {
    return assumeRoleExternalId;
  }

  public void setAssumeRoleExternalId(String assumeRoleExternalId) {
    this.assumeRoleExternalId = assumeRoleExternalId;
  }

  public InputS3 verifyKPLCheckSums(Boolean verifyKPLCheckSums) {
    this.verifyKPLCheckSums = verifyKPLCheckSums;
    return this;
  }

   /**
   * Verify Kinesis Producer Library (KPL) event checksums
   * @return verifyKPLCheckSums
  **/
  @Schema(description = "Verify Kinesis Producer Library (KPL) event checksums")
  public Boolean isVerifyKPLCheckSums() {
    return verifyKPLCheckSums;
  }

  public void setVerifyKPLCheckSums(Boolean verifyKPLCheckSums) {
    this.verifyKPLCheckSums = verifyKPLCheckSums;
  }

  public InputS3 queueName(String queueName) {
    this.queueName = queueName;
    return this;
  }

   /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: &#x27;{url}/myQueueName&#x27;. E.g., &#x27;https://host:port/myQueueName&#x27;. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: &#x60;https://host:port/myQueue-${C.vars.myVar}&#x60;.
   * @return queueName
  **/
  @Schema(description = "The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.")
  public String getQueueName() {
    return queueName;
  }

  public void setQueueName(String queueName) {
    this.queueName = queueName;
  }

  public InputS3 fileFilter(String fileFilter) {
    this.fileFilter = fileFilter;
    return this;
  }

   /**
   * Regex matching file names to download and process. Defaults to: .*
   * @return fileFilter
  **/
  @Schema(description = "Regex matching file names to download and process. Defaults to: .*")
  public String getFileFilter() {
    return fileFilter;
  }

  public void setFileFilter(String fileFilter) {
    this.fileFilter = fileFilter;
  }

  public InputS3 visibilityTimeout(BigDecimal visibilityTimeout) {
    this.visibilityTimeout = visibilityTimeout;
    return this;
  }

   /**
   * The duration (in seconds) that received messages are hidden from subsequent retrieve requests, after being retrieved by a ReceiveMessage request. This value also automatically extends this duration, to prevent it from expiring before processing completes.
   * minimum: 0
   * maximum: 43200
   * @return visibilityTimeout
  **/
  @Schema(description = "The duration (in seconds) that received messages are hidden from subsequent retrieve requests, after being retrieved by a ReceiveMessage request. This value also automatically extends this duration, to prevent it from expiring before processing completes.")
  public BigDecimal getVisibilityTimeout() {
    return visibilityTimeout;
  }

  public void setVisibilityTimeout(BigDecimal visibilityTimeout) {
    this.visibilityTimeout = visibilityTimeout;
  }

  public InputS3 numReceivers(BigDecimal numReceivers) {
    this.numReceivers = numReceivers;
    return this;
  }

   /**
   * The Number of receiver processes to run, the higher the number the better throughput at the expense of CPU overhead
   * minimum: 1
   * maximum: 100
   * @return numReceivers
  **/
  @Schema(description = "The Number of receiver processes to run, the higher the number the better throughput at the expense of CPU overhead")
  public BigDecimal getNumReceivers() {
    return numReceivers;
  }

  public void setNumReceivers(BigDecimal numReceivers) {
    this.numReceivers = numReceivers;
  }

  public InputS3 maxMessages(BigDecimal maxMessages) {
    this.maxMessages = maxMessages;
    return this;
  }

   /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   * minimum: 1
   * maximum: 10
   * @return maxMessages
  **/
  @Schema(description = "The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.")
  public BigDecimal getMaxMessages() {
    return maxMessages;
  }

  public void setMaxMessages(BigDecimal maxMessages) {
    this.maxMessages = maxMessages;
  }

  public InputS3 servicePeriodSecs(BigDecimal servicePeriodSecs) {
    this.servicePeriodSecs = servicePeriodSecs;
    return this;
  }

   /**
   * The duration (in seconds) which pollers should be validated and restarted if exited
   * minimum: 1
   * maximum: 10
   * @return servicePeriodSecs
  **/
  @Schema(description = "The duration (in seconds) which pollers should be validated and restarted if exited")
  public BigDecimal getServicePeriodSecs() {
    return servicePeriodSecs;
  }

  public void setServicePeriodSecs(BigDecimal servicePeriodSecs) {
    this.servicePeriodSecs = servicePeriodSecs;
  }

  public InputS3 skipOnError(Boolean skipOnError) {
    this.skipOnError = skipOnError;
    return this;
  }

   /**
   * Toggle to Yes to skip files that trigger a processing error. Defaults to No, which enables retries after processing errors.
   * @return skipOnError
  **/
  @Schema(description = "Toggle to Yes to skip files that trigger a processing error. Defaults to No, which enables retries after processing errors.")
  public Boolean isSkipOnError() {
    return skipOnError;
  }

  public void setSkipOnError(Boolean skipOnError) {
    this.skipOnError = skipOnError;
  }

  public InputS3 prefix(String prefix) {
    this.prefix = prefix;
    return this;
  }

   /**
   * A prefix that is applied to the metrics provided by Cribl LogStream
   * @return prefix
  **/
  @Schema(description = "A prefix that is applied to the metrics provided by Cribl LogStream")
  public String getPrefix() {
    return prefix;
  }

  public void setPrefix(String prefix) {
    this.prefix = prefix;
  }

  public InputS3 queueType(QueueTypeEnum queueType) {
    this.queueType = queueType;
    return this;
  }

   /**
   * The queue type used (or created). Defaults to Standard
   * @return queueType
  **/
  @Schema(description = "The queue type used (or created). Defaults to Standard")
  public QueueTypeEnum getQueueType() {
    return queueType;
  }

  public void setQueueType(QueueTypeEnum queueType) {
    this.queueType = queueType;
  }

  public InputS3 awsAccountId(String awsAccountId) {
    this.awsAccountId = awsAccountId;
    return this;
  }

   /**
   * SQS queue owner&#x27;s AWS account ID. Leave empty if SQS queue is in same AWS account.
   * @return awsAccountId
  **/
  @Schema(description = "SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.")
  public String getAwsAccountId() {
    return awsAccountId;
  }

  public void setAwsAccountId(String awsAccountId) {
    this.awsAccountId = awsAccountId;
  }

  public InputS3 createQueue(Boolean createQueue) {
    this.createQueue = createQueue;
    return this;
  }

   /**
   * Create queue if it does not exist.
   * @return createQueue
  **/
  @Schema(description = "Create queue if it does not exist.")
  public Boolean isCreateQueue() {
    return createQueue;
  }

  public void setCreateQueue(Boolean createQueue) {
    this.createQueue = createQueue;
  }

  public InputS3 samples(List<InputSplunkSamples> samples) {
    this.samples = samples;
    return this;
  }

  public InputS3 addSamplesItem(InputSplunkSamples samplesItem) {
    if (this.samples == null) {
      this.samples = new ArrayList<>();
    }
    this.samples.add(samplesItem);
    return this;
  }

   /**
   * List of datagens
   * @return samples
  **/
  @Schema(description = "List of datagens")
  public List<InputSplunkSamples> getSamples() {
    return samples;
  }

  public void setSamples(List<InputSplunkSamples> samples) {
    this.samples = samples;
  }

  public InputS3 socketTimeout(BigDecimal socketTimeout) {
    this.socketTimeout = socketTimeout;
    return this;
  }

   /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   * minimum: 1
   * maximum: 43200
   * @return socketTimeout
  **/
  @Schema(description = "Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.")
  public BigDecimal getSocketTimeout() {
    return socketTimeout;
  }

  public void setSocketTimeout(BigDecimal socketTimeout) {
    this.socketTimeout = socketTimeout;
  }

  public InputS3 enableSQSAssumeRole(Boolean enableSQSAssumeRole) {
    this.enableSQSAssumeRole = enableSQSAssumeRole;
    return this;
  }

   /**
   * Use Assume Role credentials when accessing SQS.
   * @return enableSQSAssumeRole
  **/
  @Schema(description = "Use Assume Role credentials when accessing SQS.")
  public Boolean isEnableSQSAssumeRole() {
    return enableSQSAssumeRole;
  }

  public void setEnableSQSAssumeRole(Boolean enableSQSAssumeRole) {
    this.enableSQSAssumeRole = enableSQSAssumeRole;
  }

  public InputS3 preprocess(SavedJobCollectionInputPreprocess preprocess) {
    this.preprocess = preprocess;
    return this;
  }

   /**
   * Get preprocess
   * @return preprocess
  **/
  @Schema(description = "")
  public SavedJobCollectionInputPreprocess getPreprocess() {
    return preprocess;
  }

  public void setPreprocess(SavedJobCollectionInputPreprocess preprocess) {
    this.preprocess = preprocess;
  }

  public InputS3 enableHeader(Boolean enableHeader) {
    this.enableHeader = enableHeader;
    return this;
  }

   /**
   * If enabled, client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { \&quot;authToken\&quot; : \&quot;myToken\&quot;, \&quot;fields\&quot;: { \&quot;field1\&quot;: \&quot;value1\&quot;, \&quot;field2\&quot;: \&quot;value2\&quot; } }
   * @return enableHeader
  **/
  @Schema(description = "If enabled, client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { \"authToken\" : \"myToken\", \"fields\": { \"field1\": \"value1\", \"field2\": \"value2\" } }")
  public Boolean isEnableHeader() {
    return enableHeader;
  }

  public void setEnableHeader(Boolean enableHeader) {
    this.enableHeader = enableHeader;
  }

  public InputS3 sendToRoutes(Boolean sendToRoutes) {
    this.sendToRoutes = sendToRoutes;
    return this;
  }

   /**
   * If set to Yes, events will be sent to normal routing and event processing. Set to No if you want to select a specific Pipeline/Destination combination.
   * @return sendToRoutes
  **/
  @Schema(description = "If set to Yes, events will be sent to normal routing and event processing. Set to No if you want to select a specific Pipeline/Destination combination.")
  public Boolean isSendToRoutes() {
    return sendToRoutes;
  }

  public void setSendToRoutes(Boolean sendToRoutes) {
    this.sendToRoutes = sendToRoutes;
  }

  public InputS3 throttleRatePerSec(String throttleRatePerSec) {
    this.throttleRatePerSec = throttleRatePerSec;
    return this;
  }

   /**
   * Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
   * @return throttleRatePerSec
  **/
  @Schema(description = "Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.")
  public String getThrottleRatePerSec() {
    return throttleRatePerSec;
  }

  public void setThrottleRatePerSec(String throttleRatePerSec) {
    this.throttleRatePerSec = throttleRatePerSec;
  }

  public InputS3 tenantId(String tenantId) {
    this.tenantId = tenantId;
    return this;
  }

   /**
   * Office 365 Azure Tenant ID
   * @return tenantId
  **/
  @Schema(description = "Office 365 Azure Tenant ID")
  public String getTenantId() {
    return tenantId;
  }

  public void setTenantId(String tenantId) {
    this.tenantId = tenantId;
  }

  public InputS3 appId(String appId) {
    this.appId = appId;
    return this;
  }

   /**
   * Office 365 Azure Application ID
   * @return appId
  **/
  @Schema(description = "Office 365 Azure Application ID")
  public String getAppId() {
    return appId;
  }

  public void setAppId(String appId) {
    this.appId = appId;
  }

  public InputS3 timeout(BigDecimal timeout) {
    this.timeout = timeout;
    return this;
  }

   /**
   * HTTP request inactivity timeout, use 0 to disable
   * minimum: 0
   * maximum: 2400
   * @return timeout
  **/
  @Schema(description = "HTTP request inactivity timeout, use 0 to disable")
  public BigDecimal getTimeout() {
    return timeout;
  }

  public void setTimeout(BigDecimal timeout) {
    this.timeout = timeout;
  }

  public InputS3 keepAliveTime(BigDecimal keepAliveTime) {
    this.keepAliveTime = keepAliveTime;
    return this;
  }

   /**
   * How often workers should check in with the scheduler to keep job subscription alive
   * minimum: 10
   * @return keepAliveTime
  **/
  @Schema(description = "How often workers should check in with the scheduler to keep job subscription alive")
  public BigDecimal getKeepAliveTime() {
    return keepAliveTime;
  }

  public void setKeepAliveTime(BigDecimal keepAliveTime) {
    this.keepAliveTime = keepAliveTime;
  }

  public InputS3 maxMissedKeepAlives(BigDecimal maxMissedKeepAlives) {
    this.maxMissedKeepAlives = maxMissedKeepAlives;
    return this;
  }

   /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   * minimum: 2
   * @return maxMissedKeepAlives
  **/
  @Schema(description = "The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.")
  public BigDecimal getMaxMissedKeepAlives() {
    return maxMissedKeepAlives;
  }

  public void setMaxMissedKeepAlives(BigDecimal maxMissedKeepAlives) {
    this.maxMissedKeepAlives = maxMissedKeepAlives;
  }

  public InputS3 contentConfig(List<InputSplunkContentConfig> contentConfig) {
    this.contentConfig = contentConfig;
    return this;
  }

  public InputS3 addContentConfigItem(InputSplunkContentConfig contentConfigItem) {
    if (this.contentConfig == null) {
      this.contentConfig = new ArrayList<>();
    }
    this.contentConfig.add(contentConfigItem);
    return this;
  }

   /**
   * Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: *_/${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
   * @return contentConfig
  **/
  @Schema(description = "Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: *_/${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.")
  public List<InputSplunkContentConfig> getContentConfig() {
    return contentConfig;
  }

  public void setContentConfig(List<InputSplunkContentConfig> contentConfig) {
    this.contentConfig = contentConfig;
  }

  public InputS3 planType(PlanTypeEnum planType) {
    this.planType = planType;
    return this;
  }

   /**
   * Office 365 subscription plan for your organization, typically Enterprise
   * @return planType
  **/
  @Schema(description = "Office 365 subscription plan for your organization, typically Enterprise")
  public PlanTypeEnum getPlanType() {
    return planType;
  }

  public void setPlanType(PlanTypeEnum planType) {
    this.planType = planType;
  }

  public InputS3 publisherIdentifier(String publisherIdentifier) {
    this.publisherIdentifier = publisherIdentifier;
    return this;
  }

   /**
   * Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
   * @return publisherIdentifier
  **/
  @Schema(description = "Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)")
  public String getPublisherIdentifier() {
    return publisherIdentifier;
  }

  public void setPublisherIdentifier(String publisherIdentifier) {
    this.publisherIdentifier = publisherIdentifier;
  }

  public InputS3 url(String url) {
    this.url = url;
    return this;
  }

   /**
   * URL to use when retrieving report data.
   * @return url
  **/
  @Schema(description = "URL to use when retrieving report data.")
  public String getUrl() {
    return url;
  }

  public void setUrl(String url) {
    this.url = url;
  }

  public InputS3 interval(BigDecimal interval) {
    this.interval = interval;
    return this;
  }

   /**
   * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.
   * minimum: 1
   * maximum: 60
   * @return interval
  **/
  @Schema(description = "How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.")
  public BigDecimal getInterval() {
    return interval;
  }

  public void setInterval(BigDecimal interval) {
    this.interval = interval;
  }

  public InputS3 startDate(String startDate) {
    this.startDate = startDate;
    return this;
  }

   /**
   * The relative time in the past for the search date range. (E.g., -3h@h) Message trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
   * @return startDate
  **/
  @Schema(description = "The relative time in the past for the search date range. (E.g., -3h@h) Message trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.")
  public String getStartDate() {
    return startDate;
  }

  public void setStartDate(String startDate) {
    this.startDate = startDate;
  }

  public InputS3 endDate(String endDate) {
    this.endDate = endDate;
    return this;
  }

   /**
   * The relative time in the past for the search date range. (E.g., -2h@h) Message trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
   * @return endDate
  **/
  @Schema(description = "The relative time in the past for the search date range. (E.g., -2h@h) Message trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.")
  public String getEndDate() {
    return endDate;
  }

  public void setEndDate(String endDate) {
    this.endDate = endDate;
  }

  public InputS3 logLevel(LogLevelEnum logLevel) {
    this.logLevel = logLevel;
    return this;
  }

   /**
   * Collector runtime Log Level
   * @return logLevel
  **/
  @Schema(description = "Collector runtime Log Level")
  public LogLevelEnum getLogLevel() {
    return logLevel;
  }

  public void setLogLevel(LogLevelEnum logLevel) {
    this.logLevel = logLevel;
  }

  public InputS3 disableTimeFilter(Boolean disableTimeFilter) {
    this.disableTimeFilter = disableTimeFilter;
    return this;
  }

   /**
   * Used to disable collector event time filtering when a date range is specified.
   * @return disableTimeFilter
  **/
  @Schema(description = "Used to disable collector event time filtering when a date range is specified.")
  public Boolean isDisableTimeFilter() {
    return disableTimeFilter;
  }

  public void setDisableTimeFilter(Boolean disableTimeFilter) {
    this.disableTimeFilter = disableTimeFilter;
  }

  public InputS3 dimensionList(List<String> dimensionList) {
    this.dimensionList = dimensionList;
    return this;
  }

  public InputS3 addDimensionListItem(String dimensionListItem) {
    if (this.dimensionList == null) {
      this.dimensionList = new ArrayList<>();
    }
    this.dimensionList.add(dimensionListItem);
    return this;
  }

   /**
   * Other dimensions to include in events
   * @return dimensionList
  **/
  @Schema(description = "Other dimensions to include in events")
  public List<String> getDimensionList() {
    return dimensionList;
  }

  public void setDimensionList(List<String> dimensionList) {
    this.dimensionList = dimensionList;
  }

  public InputS3 discoveryType(DiscoveryTypeEnum discoveryType) {
    this.discoveryType = discoveryType;
    return this;
  }

   /**
   * Target discovery mechanism, use static to manually enter a list of targets
   * @return discoveryType
  **/
  @Schema(description = "Target discovery mechanism, use static to manually enter a list of targets")
  public DiscoveryTypeEnum getDiscoveryType() {
    return discoveryType;
  }

  public void setDiscoveryType(DiscoveryTypeEnum discoveryType) {
    this.discoveryType = discoveryType;
  }

  public InputS3 prometheusAPI(String prometheusAPI) {
    this.prometheusAPI = prometheusAPI;
    return this;
  }

   /**
   * Absolute path on which to listen for Grafana Agent&#x27;s Remote Write requests. Defaults to /api/prom/push, which will expand as: http://&lt;yourupstreamURL&gt;:&lt;yourport&gt;/api/prom/push.
   * @return prometheusAPI
  **/
  @Schema(description = "Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: http://<yourupstreamURL>:<yourport>/api/prom/push.")
  public String getPrometheusAPI() {
    return prometheusAPI;
  }

  public void setPrometheusAPI(String prometheusAPI) {
    this.prometheusAPI = prometheusAPI;
  }

  public InputS3 keepAliveTimeout(BigDecimal keepAliveTimeout) {
    this.keepAliveTimeout = keepAliveTimeout;
    return this;
  }

   /**
   * Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write&#x27;s request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent&#x27;s embedded Prometheus would attempt to keep connections open for up to 5 minutes.
   * minimum: 1
   * maximum: 600
   * @return keepAliveTimeout
  **/
  @Schema(description = "Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.")
  public BigDecimal getKeepAliveTimeout() {
    return keepAliveTimeout;
  }

  public void setKeepAliveTimeout(BigDecimal keepAliveTimeout) {
    this.keepAliveTimeout = keepAliveTimeout;
  }

  public InputS3 lokiAPI(String lokiAPI) {
    this.lokiAPI = lokiAPI;
    return this;
  }

   /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: &#x27;http://&lt;yourupstreamURL&gt;:&lt;yourport&gt;/loki/api/v1/push&#x27;.
   * @return lokiAPI
  **/
  @Schema(required = true, description = "Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'.")
  public String getLokiAPI() {
    return lokiAPI;
  }

  public void setLokiAPI(String lokiAPI) {
    this.lokiAPI = lokiAPI;
  }

  public InputS3 prometheusAuth(InputSplunkPrometheusAuth prometheusAuth) {
    this.prometheusAuth = prometheusAuth;
    return this;
  }

   /**
   * Get prometheusAuth
   * @return prometheusAuth
  **/
  @Schema(description = "")
  public InputSplunkPrometheusAuth getPrometheusAuth() {
    return prometheusAuth;
  }

  public void setPrometheusAuth(InputSplunkPrometheusAuth prometheusAuth) {
    this.prometheusAuth = prometheusAuth;
  }

  public InputS3 lokiAuth(InputSplunkLokiAuth lokiAuth) {
    this.lokiAuth = lokiAuth;
    return this;
  }

   /**
   * Get lokiAuth
   * @return lokiAuth
  **/
  @Schema(description = "")
  public InputSplunkLokiAuth getLokiAuth() {
    return lokiAuth;
  }

  public void setLokiAuth(InputSplunkLokiAuth lokiAuth) {
    this.lokiAuth = lokiAuth;
  }

  public InputS3 topicName(String topicName) {
    this.topicName = topicName;
    return this;
  }

   /**
   * ID of the topic to receive events from.
   * @return topicName
  **/
  @Schema(required = true, description = "ID of the topic to receive events from.")
  public String getTopicName() {
    return topicName;
  }

  public void setTopicName(String topicName) {
    this.topicName = topicName;
  }

  public InputS3 subscriptionName(String subscriptionName) {
    this.subscriptionName = subscriptionName;
    return this;
  }

   /**
   * ID of the subscription to use when receiving events.
   * @return subscriptionName
  **/
  @Schema(required = true, description = "ID of the subscription to use when receiving events.")
  public String getSubscriptionName() {
    return subscriptionName;
  }

  public void setSubscriptionName(String subscriptionName) {
    this.subscriptionName = subscriptionName;
  }

  public InputS3 createTopic(Boolean createTopic) {
    this.createTopic = createTopic;
    return this;
  }

   /**
   * If enabled, create topic if it does not exist
   * @return createTopic
  **/
  @Schema(description = "If enabled, create topic if it does not exist")
  public Boolean isCreateTopic() {
    return createTopic;
  }

  public void setCreateTopic(Boolean createTopic) {
    this.createTopic = createTopic;
  }

  public InputS3 createSubscription(Boolean createSubscription) {
    this.createSubscription = createSubscription;
    return this;
  }

   /**
   * If enabled, create subscription if it does not exist
   * @return createSubscription
  **/
  @Schema(description = "If enabled, create subscription if it does not exist")
  public Boolean isCreateSubscription() {
    return createSubscription;
  }

  public void setCreateSubscription(Boolean createSubscription) {
    this.createSubscription = createSubscription;
  }

  public InputS3 googleAuthMethod(GoogleAuthMethodEnum googleAuthMethod) {
    this.googleAuthMethod = googleAuthMethod;
    return this;
  }

   /**
   * Google authentication method. Choose Auto to use environment variables PUBSUB_PROJECT and PUBSUB_CREDENTIALS.
   * @return googleAuthMethod
  **/
  @Schema(description = "Google authentication method. Choose Auto to use environment variables PUBSUB_PROJECT and PUBSUB_CREDENTIALS.")
  public GoogleAuthMethodEnum getGoogleAuthMethod() {
    return googleAuthMethod;
  }

  public void setGoogleAuthMethod(GoogleAuthMethodEnum googleAuthMethod) {
    this.googleAuthMethod = googleAuthMethod;
  }

  public InputS3 serviceAccountCredentials(Object serviceAccountCredentials) {
    this.serviceAccountCredentials = serviceAccountCredentials;
    return this;
  }

   /**
   * Get serviceAccountCredentials
   * @return serviceAccountCredentials
  **/
  @Schema(description = "")
  public Object getServiceAccountCredentials() {
    return serviceAccountCredentials;
  }

  public void setServiceAccountCredentials(Object serviceAccountCredentials) {
    this.serviceAccountCredentials = serviceAccountCredentials;
  }

  public InputS3 secret(Object secret) {
    this.secret = secret;
    return this;
  }

   /**
   * Get secret
   * @return secret
  **/
  @Schema(description = "")
  public Object getSecret() {
    return secret;
  }

  public void setSecret(Object secret) {
    this.secret = secret;
  }

  public InputS3 maxBacklog(BigDecimal maxBacklog) {
    this.maxBacklog = maxBacklog;
    return this;
  }

   /**
   * Maximum number of events waiting to be processed before backpressure is applied.
   * minimum: 1
   * @return maxBacklog
  **/
  @Schema(description = "Maximum number of events waiting to be processed before backpressure is applied.")
  public BigDecimal getMaxBacklog() {
    return maxBacklog;
  }

  public void setMaxBacklog(BigDecimal maxBacklog) {
    this.maxBacklog = maxBacklog;
  }

  public InputS3 requestTimeout(BigDecimal requestTimeout) {
    this.requestTimeout = requestTimeout;
    return this;
  }

   /**
   * Pull request timeout, in milliseconds.
   * minimum: 10000
   * @return requestTimeout
  **/
  @Schema(description = "Pull request timeout, in milliseconds.")
  public BigDecimal getRequestTimeout() {
    return requestTimeout;
  }

  public void setRequestTimeout(BigDecimal requestTimeout) {
    this.requestTimeout = requestTimeout;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    InputS3 inputS3 = (InputS3) o;
    return Objects.equals(this.id, inputS3.id) &&
        Objects.equals(this.type, inputS3.type) &&
        Objects.equals(this.disabled, inputS3.disabled) &&
        Objects.equals(this.pipeline, inputS3.pipeline) &&
        Objects.equals(this.host, inputS3.host) &&
        Objects.equals(this.port, inputS3.port) &&
        Objects.equals(this.tls, inputS3.tls) &&
        Objects.equals(this.ipWhitelistRegex, inputS3.ipWhitelistRegex) &&
        Objects.equals(this.maxActiveCxn, inputS3.maxActiveCxn) &&
        Objects.equals(this.enableProxyHeader, inputS3.enableProxyHeader) &&
        Objects.equals(this.metadata, inputS3.metadata) &&
        Objects.equals(this.breakerRulesets, inputS3.breakerRulesets) &&
        Objects.equals(this.staleChannelFlushMs, inputS3.staleChannelFlushMs) &&
        Objects.equals(this.authTokens, inputS3.authTokens) &&
        Objects.equals(this.maxActiveReq, inputS3.maxActiveReq) &&
        Objects.equals(this.activityLogSampleRate, inputS3.activityLogSampleRate) &&
        Objects.equals(this.elasticAPI, inputS3.elasticAPI) &&
        Objects.equals(this.splunkHecAPI, inputS3.splunkHecAPI) &&
        Objects.equals(this.allowedIndexes, inputS3.allowedIndexes) &&
        Objects.equals(this.splunkHecAcks, inputS3.splunkHecAcks) &&
        Objects.equals(this.udpPort, inputS3.udpPort) &&
        Objects.equals(this.tcpPort, inputS3.tcpPort) &&
        Objects.equals(this.maxBufferSize, inputS3.maxBufferSize) &&
        Objects.equals(this.timestampTimezone, inputS3.timestampTimezone) &&
        Objects.equals(this.singleMsgUdpPackets, inputS3.singleMsgUdpPackets) &&
        Objects.equals(this.keepFieldsList, inputS3.keepFieldsList) &&
        Objects.equals(this.authType, inputS3.authType) &&
        Objects.equals(this.criblAPI, inputS3.criblAPI) &&
        Objects.equals(this.allowedPaths, inputS3.allowedPaths) &&
        Objects.equals(this.allowedMethods, inputS3.allowedMethods) &&
        Objects.equals(this.brokers, inputS3.brokers) &&
        Objects.equals(this.topics, inputS3.topics) &&
        Objects.equals(this.groupId, inputS3.groupId) &&
        Objects.equals(this.fromBeginning, inputS3.fromBeginning) &&
        Objects.equals(this.kafkaSchemaRegistry, inputS3.kafkaSchemaRegistry) &&
        Objects.equals(this.sasl, inputS3.sasl) &&
        Objects.equals(this.sessionTimeout, inputS3.sessionTimeout) &&
        Objects.equals(this.rebalanceTimeout, inputS3.rebalanceTimeout) &&
        Objects.equals(this.heartbeatInterval, inputS3.heartbeatInterval) &&
        Objects.equals(this.streamName, inputS3.streamName) &&
        Objects.equals(this.serviceInterval, inputS3.serviceInterval) &&
        Objects.equals(this.shardExpr, inputS3.shardExpr) &&
        Objects.equals(this.shardIteratorType, inputS3.shardIteratorType) &&
        Objects.equals(this.payloadFormat, inputS3.payloadFormat) &&
        Objects.equals(this.awsAuthenticationMethod, inputS3.awsAuthenticationMethod) &&
        Objects.equals(this.awsSecretKey, inputS3.awsSecretKey) &&
        Objects.equals(this.region, inputS3.region) &&
        Objects.equals(this.endpoint, inputS3.endpoint) &&
        Objects.equals(this.signatureVersion, inputS3.signatureVersion) &&
        Objects.equals(this.reuseConnections, inputS3.reuseConnections) &&
        Objects.equals(this.rejectUnauthorized, inputS3.rejectUnauthorized) &&
        Objects.equals(this.enableAssumeRole, inputS3.enableAssumeRole) &&
        Objects.equals(this.assumeRoleArn, inputS3.assumeRoleArn) &&
        Objects.equals(this.assumeRoleExternalId, inputS3.assumeRoleExternalId) &&
        Objects.equals(this.verifyKPLCheckSums, inputS3.verifyKPLCheckSums) &&
        Objects.equals(this.queueName, inputS3.queueName) &&
        Objects.equals(this.fileFilter, inputS3.fileFilter) &&
        Objects.equals(this.visibilityTimeout, inputS3.visibilityTimeout) &&
        Objects.equals(this.numReceivers, inputS3.numReceivers) &&
        Objects.equals(this.maxMessages, inputS3.maxMessages) &&
        Objects.equals(this.servicePeriodSecs, inputS3.servicePeriodSecs) &&
        Objects.equals(this.skipOnError, inputS3.skipOnError) &&
        Objects.equals(this.prefix, inputS3.prefix) &&
        Objects.equals(this.queueType, inputS3.queueType) &&
        Objects.equals(this.awsAccountId, inputS3.awsAccountId) &&
        Objects.equals(this.createQueue, inputS3.createQueue) &&
        Objects.equals(this.samples, inputS3.samples) &&
        Objects.equals(this.socketTimeout, inputS3.socketTimeout) &&
        Objects.equals(this.enableSQSAssumeRole, inputS3.enableSQSAssumeRole) &&
        Objects.equals(this.preprocess, inputS3.preprocess) &&
        Objects.equals(this.enableHeader, inputS3.enableHeader) &&
        Objects.equals(this.sendToRoutes, inputS3.sendToRoutes) &&
        Objects.equals(this.throttleRatePerSec, inputS3.throttleRatePerSec) &&
        Objects.equals(this.tenantId, inputS3.tenantId) &&
        Objects.equals(this.appId, inputS3.appId) &&
        Objects.equals(this.timeout, inputS3.timeout) &&
        Objects.equals(this.keepAliveTime, inputS3.keepAliveTime) &&
        Objects.equals(this.maxMissedKeepAlives, inputS3.maxMissedKeepAlives) &&
        Objects.equals(this.contentConfig, inputS3.contentConfig) &&
        Objects.equals(this.planType, inputS3.planType) &&
        Objects.equals(this.publisherIdentifier, inputS3.publisherIdentifier) &&
        Objects.equals(this.url, inputS3.url) &&
        Objects.equals(this.interval, inputS3.interval) &&
        Objects.equals(this.startDate, inputS3.startDate) &&
        Objects.equals(this.endDate, inputS3.endDate) &&
        Objects.equals(this.logLevel, inputS3.logLevel) &&
        Objects.equals(this.disableTimeFilter, inputS3.disableTimeFilter) &&
        Objects.equals(this.dimensionList, inputS3.dimensionList) &&
        Objects.equals(this.discoveryType, inputS3.discoveryType) &&
        Objects.equals(this.prometheusAPI, inputS3.prometheusAPI) &&
        Objects.equals(this.keepAliveTimeout, inputS3.keepAliveTimeout) &&
        Objects.equals(this.lokiAPI, inputS3.lokiAPI) &&
        Objects.equals(this.prometheusAuth, inputS3.prometheusAuth) &&
        Objects.equals(this.lokiAuth, inputS3.lokiAuth) &&
        Objects.equals(this.topicName, inputS3.topicName) &&
        Objects.equals(this.subscriptionName, inputS3.subscriptionName) &&
        Objects.equals(this.createTopic, inputS3.createTopic) &&
        Objects.equals(this.createSubscription, inputS3.createSubscription) &&
        Objects.equals(this.googleAuthMethod, inputS3.googleAuthMethod) &&
        Objects.equals(this.serviceAccountCredentials, inputS3.serviceAccountCredentials) &&
        Objects.equals(this.secret, inputS3.secret) &&
        Objects.equals(this.maxBacklog, inputS3.maxBacklog) &&
        Objects.equals(this.requestTimeout, inputS3.requestTimeout);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, type, disabled, pipeline, host, port, tls, ipWhitelistRegex, maxActiveCxn, enableProxyHeader, metadata, breakerRulesets, staleChannelFlushMs, authTokens, maxActiveReq, activityLogSampleRate, elasticAPI, splunkHecAPI, allowedIndexes, splunkHecAcks, udpPort, tcpPort, maxBufferSize, timestampTimezone, singleMsgUdpPackets, keepFieldsList, authType, criblAPI, allowedPaths, allowedMethods, brokers, topics, groupId, fromBeginning, kafkaSchemaRegistry, sasl, sessionTimeout, rebalanceTimeout, heartbeatInterval, streamName, serviceInterval, shardExpr, shardIteratorType, payloadFormat, awsAuthenticationMethod, awsSecretKey, region, endpoint, signatureVersion, reuseConnections, rejectUnauthorized, enableAssumeRole, assumeRoleArn, assumeRoleExternalId, verifyKPLCheckSums, queueName, fileFilter, visibilityTimeout, numReceivers, maxMessages, servicePeriodSecs, skipOnError, prefix, queueType, awsAccountId, createQueue, samples, socketTimeout, enableSQSAssumeRole, preprocess, enableHeader, sendToRoutes, throttleRatePerSec, tenantId, appId, timeout, keepAliveTime, maxMissedKeepAlives, contentConfig, planType, publisherIdentifier, url, interval, startDate, endDate, logLevel, disableTimeFilter, dimensionList, discoveryType, prometheusAPI, keepAliveTimeout, lokiAPI, prometheusAuth, lokiAuth, topicName, subscriptionName, createTopic, createSubscription, googleAuthMethod, serviceAccountCredentials, secret, maxBacklog, requestTimeout);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class InputS3 {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    disabled: ").append(toIndentedString(disabled)).append("\n");
    sb.append("    pipeline: ").append(toIndentedString(pipeline)).append("\n");
    sb.append("    host: ").append(toIndentedString(host)).append("\n");
    sb.append("    port: ").append(toIndentedString(port)).append("\n");
    sb.append("    tls: ").append(toIndentedString(tls)).append("\n");
    sb.append("    ipWhitelistRegex: ").append(toIndentedString(ipWhitelistRegex)).append("\n");
    sb.append("    maxActiveCxn: ").append(toIndentedString(maxActiveCxn)).append("\n");
    sb.append("    enableProxyHeader: ").append(toIndentedString(enableProxyHeader)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    breakerRulesets: ").append(toIndentedString(breakerRulesets)).append("\n");
    sb.append("    staleChannelFlushMs: ").append(toIndentedString(staleChannelFlushMs)).append("\n");
    sb.append("    authTokens: ").append(toIndentedString(authTokens)).append("\n");
    sb.append("    maxActiveReq: ").append(toIndentedString(maxActiveReq)).append("\n");
    sb.append("    activityLogSampleRate: ").append(toIndentedString(activityLogSampleRate)).append("\n");
    sb.append("    elasticAPI: ").append(toIndentedString(elasticAPI)).append("\n");
    sb.append("    splunkHecAPI: ").append(toIndentedString(splunkHecAPI)).append("\n");
    sb.append("    allowedIndexes: ").append(toIndentedString(allowedIndexes)).append("\n");
    sb.append("    splunkHecAcks: ").append(toIndentedString(splunkHecAcks)).append("\n");
    sb.append("    udpPort: ").append(toIndentedString(udpPort)).append("\n");
    sb.append("    tcpPort: ").append(toIndentedString(tcpPort)).append("\n");
    sb.append("    maxBufferSize: ").append(toIndentedString(maxBufferSize)).append("\n");
    sb.append("    timestampTimezone: ").append(toIndentedString(timestampTimezone)).append("\n");
    sb.append("    singleMsgUdpPackets: ").append(toIndentedString(singleMsgUdpPackets)).append("\n");
    sb.append("    keepFieldsList: ").append(toIndentedString(keepFieldsList)).append("\n");
    sb.append("    authType: ").append(toIndentedString(authType)).append("\n");
    sb.append("    criblAPI: ").append(toIndentedString(criblAPI)).append("\n");
    sb.append("    allowedPaths: ").append(toIndentedString(allowedPaths)).append("\n");
    sb.append("    allowedMethods: ").append(toIndentedString(allowedMethods)).append("\n");
    sb.append("    brokers: ").append(toIndentedString(brokers)).append("\n");
    sb.append("    topics: ").append(toIndentedString(topics)).append("\n");
    sb.append("    groupId: ").append(toIndentedString(groupId)).append("\n");
    sb.append("    fromBeginning: ").append(toIndentedString(fromBeginning)).append("\n");
    sb.append("    kafkaSchemaRegistry: ").append(toIndentedString(kafkaSchemaRegistry)).append("\n");
    sb.append("    sasl: ").append(toIndentedString(sasl)).append("\n");
    sb.append("    sessionTimeout: ").append(toIndentedString(sessionTimeout)).append("\n");
    sb.append("    rebalanceTimeout: ").append(toIndentedString(rebalanceTimeout)).append("\n");
    sb.append("    heartbeatInterval: ").append(toIndentedString(heartbeatInterval)).append("\n");
    sb.append("    streamName: ").append(toIndentedString(streamName)).append("\n");
    sb.append("    serviceInterval: ").append(toIndentedString(serviceInterval)).append("\n");
    sb.append("    shardExpr: ").append(toIndentedString(shardExpr)).append("\n");
    sb.append("    shardIteratorType: ").append(toIndentedString(shardIteratorType)).append("\n");
    sb.append("    payloadFormat: ").append(toIndentedString(payloadFormat)).append("\n");
    sb.append("    awsAuthenticationMethod: ").append(toIndentedString(awsAuthenticationMethod)).append("\n");
    sb.append("    awsSecretKey: ").append(toIndentedString(awsSecretKey)).append("\n");
    sb.append("    region: ").append(toIndentedString(region)).append("\n");
    sb.append("    endpoint: ").append(toIndentedString(endpoint)).append("\n");
    sb.append("    signatureVersion: ").append(toIndentedString(signatureVersion)).append("\n");
    sb.append("    reuseConnections: ").append(toIndentedString(reuseConnections)).append("\n");
    sb.append("    rejectUnauthorized: ").append(toIndentedString(rejectUnauthorized)).append("\n");
    sb.append("    enableAssumeRole: ").append(toIndentedString(enableAssumeRole)).append("\n");
    sb.append("    assumeRoleArn: ").append(toIndentedString(assumeRoleArn)).append("\n");
    sb.append("    assumeRoleExternalId: ").append(toIndentedString(assumeRoleExternalId)).append("\n");
    sb.append("    verifyKPLCheckSums: ").append(toIndentedString(verifyKPLCheckSums)).append("\n");
    sb.append("    queueName: ").append(toIndentedString(queueName)).append("\n");
    sb.append("    fileFilter: ").append(toIndentedString(fileFilter)).append("\n");
    sb.append("    visibilityTimeout: ").append(toIndentedString(visibilityTimeout)).append("\n");
    sb.append("    numReceivers: ").append(toIndentedString(numReceivers)).append("\n");
    sb.append("    maxMessages: ").append(toIndentedString(maxMessages)).append("\n");
    sb.append("    servicePeriodSecs: ").append(toIndentedString(servicePeriodSecs)).append("\n");
    sb.append("    skipOnError: ").append(toIndentedString(skipOnError)).append("\n");
    sb.append("    prefix: ").append(toIndentedString(prefix)).append("\n");
    sb.append("    queueType: ").append(toIndentedString(queueType)).append("\n");
    sb.append("    awsAccountId: ").append(toIndentedString(awsAccountId)).append("\n");
    sb.append("    createQueue: ").append(toIndentedString(createQueue)).append("\n");
    sb.append("    samples: ").append(toIndentedString(samples)).append("\n");
    sb.append("    socketTimeout: ").append(toIndentedString(socketTimeout)).append("\n");
    sb.append("    enableSQSAssumeRole: ").append(toIndentedString(enableSQSAssumeRole)).append("\n");
    sb.append("    preprocess: ").append(toIndentedString(preprocess)).append("\n");
    sb.append("    enableHeader: ").append(toIndentedString(enableHeader)).append("\n");
    sb.append("    sendToRoutes: ").append(toIndentedString(sendToRoutes)).append("\n");
    sb.append("    throttleRatePerSec: ").append(toIndentedString(throttleRatePerSec)).append("\n");
    sb.append("    tenantId: ").append(toIndentedString(tenantId)).append("\n");
    sb.append("    appId: ").append(toIndentedString(appId)).append("\n");
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("    keepAliveTime: ").append(toIndentedString(keepAliveTime)).append("\n");
    sb.append("    maxMissedKeepAlives: ").append(toIndentedString(maxMissedKeepAlives)).append("\n");
    sb.append("    contentConfig: ").append(toIndentedString(contentConfig)).append("\n");
    sb.append("    planType: ").append(toIndentedString(planType)).append("\n");
    sb.append("    publisherIdentifier: ").append(toIndentedString(publisherIdentifier)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    interval: ").append(toIndentedString(interval)).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    endDate: ").append(toIndentedString(endDate)).append("\n");
    sb.append("    logLevel: ").append(toIndentedString(logLevel)).append("\n");
    sb.append("    disableTimeFilter: ").append(toIndentedString(disableTimeFilter)).append("\n");
    sb.append("    dimensionList: ").append(toIndentedString(dimensionList)).append("\n");
    sb.append("    discoveryType: ").append(toIndentedString(discoveryType)).append("\n");
    sb.append("    prometheusAPI: ").append(toIndentedString(prometheusAPI)).append("\n");
    sb.append("    keepAliveTimeout: ").append(toIndentedString(keepAliveTimeout)).append("\n");
    sb.append("    lokiAPI: ").append(toIndentedString(lokiAPI)).append("\n");
    sb.append("    prometheusAuth: ").append(toIndentedString(prometheusAuth)).append("\n");
    sb.append("    lokiAuth: ").append(toIndentedString(lokiAuth)).append("\n");
    sb.append("    topicName: ").append(toIndentedString(topicName)).append("\n");
    sb.append("    subscriptionName: ").append(toIndentedString(subscriptionName)).append("\n");
    sb.append("    createTopic: ").append(toIndentedString(createTopic)).append("\n");
    sb.append("    createSubscription: ").append(toIndentedString(createSubscription)).append("\n");
    sb.append("    googleAuthMethod: ").append(toIndentedString(googleAuthMethod)).append("\n");
    sb.append("    serviceAccountCredentials: ").append(toIndentedString(serviceAccountCredentials)).append("\n");
    sb.append("    secret: ").append(toIndentedString(secret)).append("\n");
    sb.append("    maxBacklog: ").append(toIndentedString(maxBacklog)).append("\n");
    sb.append("    requestTimeout: ").append(toIndentedString(requestTimeout)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
